<!DOCTYPE html>
<html data-theme="dark">

<head>
  
<meta charset="UTF-8" />
<meta http-equiv="X-UA-Compatible" content="IE=edge" />
<meta name="viewport" content="width=device-width, initial-scale=1.0" />
<link rel="stylesheet" href="/assets/css/pico.css" />
<link rel="stylesheet" href="/assets/css/custom.css" />
<link rel="stylesheet"
      href="//cdnjs.cloudflare.com/ajax/libs/highlight.js/11.7.0/styles/atom-one-dark.min.css">
<script src="//cdnjs.cloudflare.com/ajax/libs/highlight.js/11.7.0/highlight.min.js"></script>
<script>
    hljs.initHighlightingOnLoad();
</script> 


  <style>
    article {
      background: rgb(28, 29, 33);
      max-width: 70%;
      text-align: left;
      margin: 0 auto;
      border-radius: 30px;
    }

    @media (max-width: 768px) {
      article {
        max-width: 90%;
      }

      h1 {
        font-size: large;
      }

      .date {
        font-size: medium;
      }

      p,
      li {
        font-size: 15px;
      }
    }

    p,
    li {
      font-size: 16.5px;
      line-height: 32px;
    }

    h1 {
      text-align: center;
      margin-bottom: 10px;
    }

    .meta p {
      text-align: center;
    }

    .date {
      text-align: center;
    }

    .toc {
      position: fixed;
      float: left;
      max-width: 50px;
      max-height: 50px;
      margin-top: 200px;
      text-align: center;
    }

    h2 {
      font-size: x-large;
      color: peru;
    }

    h3 {
      font-size: large;
      color: rgb(205, 158, 112);
    }

    h4 {
      font-size: medium;
      color: pink;
    }

    strong {
      color: rgb(182, 230, 240);
    }
  </style>
  <title>MIT6.S081-操作系统</title>
</head>

<body onselectstart="return false">
  
<nav>
  <a href="/" class="logo">Maruka's Blog</a>
  <div class="breadcrumb">
    <ul>
      <li>
        <a href="/posts">文章</a>
      </li>
      <li>
        <a href="/category">分类</a>
      </li>
      <li>
        <a href="/about">关于</a>
      </li>
    </ul>
  </div>
</nav>

  <div>
    <div class="meta">
      <h1>MIT6.S081-操作系统</h1>
      <p>2023-06-24 17:36:35</p>
    </div>
    <article><h2 id="1-"><a class="anchor" href="#1-">#</a> 1 引言</h2>
<h3 id="11-"><a class="anchor" href="#11-">#</a> 1.1 课程内容简介</h3>
<h4 id="heading"><a class="anchor" href="#heading">#</a> 课程目标</h4>
<ol>
<li>理解操作系统的设计和实现。设计指具体结构，实现指具体代码。</li>
<li>通过现有的示例操作系统（XV6），对其进行扩展，并通过接口开发软件，以作为实践环节。</li>
</ol>
<h4 id="heading-1"><a class="anchor" href="#heading-1">#</a> 操作系统目标</h4>
<ol>
<li>硬件抽象。以便从高层次操作硬件，以获得更好的通用性和可移植性。</li>
<li>并发性。能够同时使用多个应用程序。</li>
<li>隔离性。能够隔离应用程序，防止 bug 的传播。</li>
<li>共享性。能够共享内存，从而进行数据交互。</li>
<li>安全性。拥有权限机制从而禁止或允许用户的操作。</li>
<li>高性能。操作系统应当能够发挥出硬件的全部性能。</li>
<li>生态。一个好的操作系统应当能够支持大量不同类型的应用程序。</li>
</ol>
<h3 id="12-"><a class="anchor" href="#12-">#</a> 1.2 操作系统结构</h3>
<p>计算机的最底层是其所拥有的<strong>硬件资源</strong>，包括 CPU、内存、磁盘、网卡等。</p>
<p>最上层是<strong>用户空间</strong>，用户空间中运行着大量的应用程序。</p>
<p><strong>Kernel</strong>（内核）运行在硬件资源和用户空间之间。它是一个特殊的应用程序，负责维护用户空间进程（支持上层）以及管理硬件资源（调用下层）。</p>
<p>内核提供多种服务，包括文件系统和进程管理系统、进程间通信服务、网络和硬件驱动等。</p>
<p>应用程序通过系统调用（System Call）访问内核，其形式类似函数调用，典型的系统调用有 open、write、fork 等。</p>
<h3 id="13-"><a class="anchor" href="#13-">#</a> 1.3 挑战与乐趣并存</h3>
<h4 id="heading-2"><a class="anchor" href="#heading-2">#</a> 挑战</h4>
<ol>
<li>内核的<strong>编程环境恶劣</strong>，它并没有一个方便的软件基础，需要与底层的硬件资源交互。</li>
<li>操作系统的<strong>高效性和易用性之间的矛盾</strong>。高效性意味着操作层级应较低，而易用性则需要提供高层次的抽象接口。而对操作系统开发人员来说，我们又需要提供尽可能简单、却又功能性很强的接口。</li>
<li>应用程序的<strong>灵活性和安全性之间的矛盾</strong>。内核对应用程序的限制应尽可能小，从而保证其灵活性；但同时又要限制应用程序，以避免其对硬件的直接访问，从而破坏隔离性和安全性。</li>
<li>操作系统大量服务之间的交互是困难且复杂的。</li>
<li>操作系统需要紧跟硬件的发展。</li>
</ol>
<h4 id="heading-3"><a class="anchor" href="#heading-3">#</a> 乐趣</h4>
<ol>
<li>我们需要思考操作系统服务之间的交互方式，这应当是有趣的。</li>
<li>重新思考设计操作系统使其匹配最新硬件的过程是有趣的。</li>
<li>对计算机运行原理感兴趣，喜欢构建能够被其他应用程序使用的基础架构，或是为了定位操作系统级别的程序 BUG，都需要操作系统的知识。</li>
</ol>
<h3 id="14-readwriteexit-"><a class="anchor" href="#14-readwriteexit-">#</a> 1.4 read，write，exit 系统调用</h3>
<pre><code class="language-c">//copy.c :copy input to output.

#include &quot;kernel/types.h&quot;
#include &quot;user/user.h&quot;

int main(){
  char buf[64];
  while(1){
    int n=read(0，buf，sizeof(buf));
    if(n&lt;=0) break;
    write(1，buf，n);
  }
  exit(0);
}
</code></pre>
<h4 id="read"><a class="anchor" href="#read">#</a> read</h4>
<pre><code class="language-c">int n=read(0，buf，sizeof(buf))
</code></pre>
<p>read 系统调用接受三个参数：</p>
<ol>
<li>第一个参数是<strong>文件描述符</strong>，指向一个之前打开的文件。特别地，文件描述符 0 连接到 console 的输入，文件描述符 1 连接到 console 的输出。</li>
<li>第二个参数是<strong>指向某段内存的指针</strong>，程序可通过该指针读取相应地址内存中的数据。</li>
<li>第三个参数是<strong>代码读取的最大长度</strong>，在这里是 64 个字符。</li>
</ol>
<p>一般情况下，read 的返回值是读取到的字节数。当遇到文件尾，read 返回 0；当发生错误，read 返回-1。</p>
<h4 id="write"><a class="anchor" href="#write">#</a> write</h4>
<pre><code class="language-c">write(1，buf，n);
</code></pre>
<p>write 系统调用同样接受三个参数，其与 read 相同。</p>
<h4 id="exit"><a class="anchor" href="#exit">#</a> exit</h4>
<p>exit 接受一个参数，当为 0 时代表正常退出，否则表示发生错误。</p>
<h3 id="15-open-"><a class="anchor" href="#15-open-">#</a> 1.5 open 系统调用</h3>
<pre><code class="language-c">int fd = open(&quot;output.txt&quot;， O_WRONLY | O_CREATE);
</code></pre>
<p>open 系统调用接受 2 个参数。第一个参数表示打开的文件名，第二个参数是标志位，表示在内核中的实现。</p>
<p>open 返回一个新分配的文件描述符，可被用来执行其他系统调用。</p>
<p>文件描述符对应内核维护的一个表单数据，包括该文件所包含的所有数据。每个进程都拥有独立的文件描述符空间。</p>
<h3 id="16-fork-"><a class="anchor" href="#16-fork-">#</a> 1.6 fork 系统调用</h3>
<pre><code class="language-c">int pid = fork();

if (pid == 0){
  printf(&quot;child\n&quot;);
} else {
  printf(&quot;parent\n&quot;);
}
</code></pre>
<p>fork 的作用是拷贝当前进程的内存，并创建一个新进程。两个进程独立运行。在新进程中，pid 返回 0；而在原始进程中，pid 返回新进程的 pid，它是一个大于 0 的整数。</p>
<h3 id="17-execwait-"><a class="anchor" href="#17-execwait-">#</a> 1.7 exec，wait 系统调用</h3>
<h4 id="exec"><a class="anchor" href="#exec">#</a> exec</h4>
<pre><code class="language-c">char *argv[] = {&quot;echo&quot;， &quot;this&quot;， &quot;is&quot;， &quot;echo&quot;， 0 };
exec(&quot;echo&quot;， argv);
</code></pre>
<p>exec 从文件中读取并加载指令，替代当前进程指令。第一个参数接受文件路径名，第二个参数接受传入的命令行参数。</p>
<blockquote>
<p>Linux 中没有 exec，但有 exec 族函数。在此处比较接近的是 execv，位于 <code>unistd.h</code> 中</p>
</blockquote>
<p>exec 执行会替换当前进程，因此正常情况下无返回值，当前进程直接结束。因此我们通常将 exec 和 fork 组合使用。</p>
<p><img src="https://906337931-files.gitbook.io/~/files/v0/b/gitbook-legacy-files/o/assets%2F-MHZoT2b_bcLghjAOPsJ%2F-MIPPNbcxvfU0rZb3JHn%2F-MIUKdbclTLPYY8wEZKW%2Fimage.png?alt=media&amp;token=6d077551-35b1-4d2a-a1d7-d3399beef508" alt=""></p>
<h4 id="wait"><a class="anchor" href="#wait">#</a> wait</h4>
<pre><code class="language-c">wait(&amp;status);
</code></pre>
<p>wait 接受一个 int 地址参数，内核会等待子进程完成，并将子进程的返回值写入。如果子进程成功，则 status 为 0，否则为 1。</p>
<p>exec-fork 风格系统调用代价是高昂的，它为了开启一个子进程往往需要复制整个内存。</p>
<h3 id="18-io-"><a class="anchor" href="#18-io-">#</a> 1.8 I/O 重定向</h3>
<p><img src="https://906337931-files.gitbook.io/~/files/v0/b/gitbook-legacy-files/o/assets%2F-MHZoT2b_bcLghjAOPsJ%2F-MIPPNbcxvfU0rZb3JHn%2F-MIdhkxV4q6JhvAWWhEA%2Fimage.png?alt=media&amp;token=459186e7-79db-4fc2-84db-f3512de7fbd7" alt=""></p>
<p>I/O 重定向广泛用于 Unix 管道工具。它通过 <code>&gt;</code>、<code>&lt;</code> 等管道符改变默认的输出/输入文件符，从而实现 I/O 重定向。</p>
<h2 id="lab1"><a class="anchor" href="#lab1">#</a> Lab1</h2>
<ol>
<li>获取源代码并切换到util分支</li>
</ol>
<pre><code class="language-sh">git clone git://g.csail.mit.edu/xv6-labs-2021
cd xv6-labs-2021
git checkout util
</code></pre>
<ol start="2">
<li>尝试编译运行 xv6</li>
</ol>
<pre><code class="language-sh">make qemu
</code></pre>
<p>遇到报错如下：</p>
<pre><code class="language-sh">user/sh.c: In function 'runcmd':
user/sh.c:58:1: error: infinite recursion detected [-Werror=infinite-recursion]
   58 | runcmd(struct cmd *cmd)
      | ^~~~~~
user/sh.c:89:5: note: recursive call
   89 |     runcmd(rcmd-&gt;cmd);
      |     ^~~~~~~~~~~~~~~~~
</code></pre>
<p>修改 user/sh. c 文件，添加 noreturn 编译器属性以避免警告：</p>
<pre><code class="language-c">// Execute cmd.  Never returns.
__attribute__((noreturn))
void
runcmd(struct cmd *cmd)
</code></pre>
<p>编译成功</p>
<pre><code class="language-sh">xv6 kernel is booting

hart 1 starting
hart 2 starting
init: starting sh
$ 
</code></pre>
<ol start="3">
<li>sleep 程序</li>
</ol>
<p>在 user/user. h 中创建如下别名以解决报错，或选择在 <code>user/sleep.c</code> 中引入 <code>../kernel/types.h</code> 头文件：</p>
<pre><code class="language-c">#define uint unsigned int
//or
#include &quot;../kernel/types.h&quot;
</code></pre>
<p>编写 user/sleep. c：</p>
<pre><code class="language-c">#include &quot;user.h&quot;

int main(int argc， char **argv) {
  if (argc &lt;= 1) {
    printf(&quot;lack args\n&quot;);
    exit(1);
  }
  sleep(atoi(argv[1]));
  exit(0);
}
</code></pre>
<p>修改 makefile：</p>
<pre><code class="language-c">UPROGS=\
...
	$U/_sleep\
</code></pre>
<p>重新编译并运行：</p>
<pre><code class="language-sh">$ sleep
lack args
$ sleep 10
$ 
</code></pre>
<ol start="4">
<li>ping-pong 程序</li>
</ol>
<p>c 语言中管道图示如下：</p>
<p><img src="https://img-blog.csdnimg.cn/add7f392ea684a8ca9e717ac048df5db.png" alt=""></p>
<pre><code class="language-c">#include &quot;user.h&quot;

int main() {
  int p1[2]，p2[2];
  pipe(p1);
  pipe(p2);

  if (fork() == 0) {
    char buf[32];
    close(p2[0]);
    close(p1[1]);
    //read ping
    read(p1[0]， buf， 4);
    printf(&quot;%d: received %s\n&quot;， getpid()， buf);
    close(p1[0]);
    //write pong
    write(p2[1]， &quot;pong&quot;， 4);
    close(p2[1]);
    exit(0);
  } else {
    char buf[32];
    close(p1[0]);
    close(p2[1]);
    //write ping
    write(p1[1]， &quot;ping&quot;， 4);
    close(p1[1]);
    //read pong
    read(p2[0]， buf， 4);
    printf(&quot;%d: received %s\n&quot;， getpid()， buf);
    close(p2[0]);
    exit(0);
  }
}
</code></pre>
<p>注意修改 makefile（下同）。结果如下：</p>
<pre><code class="language-sh">$ pingpong
4: received ping
3: received pong
$ 
</code></pre>
<ol start="5">
<li>素数虽然难度标的是 hard，但其实并不太难，只是需要灵活应用 pipe：</li>
</ol>
<pre><code class="language-c">#include &quot;user.h&quot;

int work(int *p， int n) {
  // 读取上一个管道传入的数据
  int num;
  read(p[0]， &amp;num， 4);
  close(p[0]);
  // 递归退出条件：无法被整除，表明是素数，打印
  if (n == 1) {
    printf(&quot;prime %d\n&quot;， num);
    return 0;
  }
  // 若不能被整除，则新建一个管道并递归，否则返回
  if (num % n != 0) {
    int p1[2];
    pipe(p1);
    write(p1[1]， &amp;num， 4);
    close(p1[1]);
    work(p1， n - 1);
  }
  return 0;
}

int main() {
  // 倒序判断是否是素数
  for (int i = 1; i &lt; 36; i++) {
    int p[2];
    pipe(p);
    write(p[1]， &amp;i， 4);
    work(p， i-1);
    close(p[1]);
  }
  exit(0);
}
</code></pre>
<p>结果如下：</p>
<pre><code class="language-sh">$ primes
prime 2
prime 3
prime 5
prime 7
prime 11
prime 13
prime 17
prime 19
prime 23
prime 29
prime 31
$ 
</code></pre>
<ol start="6">
<li>find 程序</li>
</ol>
<pre><code class="language-c">#include &quot;../kernel/types.h&quot;
#include &quot;../kernel/fs.h&quot;
#include &quot;../kernel/stat.h&quot;
#include &quot;../user/user.h&quot;

// 获取文件的base name
char *getname(char *path) {
  char *p;
  // Find first character after last slash.
  for (p = path + strlen(path); p &gt;= path &amp;&amp; *p != '/'; p--)
    ;
  p++;
  return p;
}

void find(char *path， char *filename) {
  char buf[512];
  int fd = open(path， 0);
  struct stat st;
  struct dirent de;
  fstat(fd， &amp;st);
  switch (st.type) {
    // 如果path指示一个文件，则比较base name
  case T_FILE:
    if (strcmp(filename， getname(path)) == 0)
      printf(&quot;%s\n&quot;， path);
    break;
    // 若path指示一个目录，则递归搜索目录下的所有路径
  case T_DIR:
    // 处理路径，添加分隔符
    strcpy(buf， path);
    char *p = buf + strlen(buf);
    *p++ = '/';

    while (read(fd， &amp;de， sizeof(de)) == sizeof(de)) {
      if (de.inum == 0 || strcmp(de.name， &quot;.&quot;) == 0 ||
          strcmp(de.name， &quot;..&quot;) == 0)
        continue;

      // 处理路径，将读取到的文件/目录名追加到buf作为查找路径
      memmove(p， de.name， DIRSIZ);
      p[DIRSIZ] = 0;
      find(buf， filename);
    }
    break;
  }
  close(fd);
}

int main(int argc， char *argv[]) {
  if (argc &lt; 3) {
    printf(&quot;args is too short\n&quot;);
    exit(1);
  }
  find(argv[1]， argv[2]);
  exit(0);
}
</code></pre>
<p>结果如下：</p>
<pre><code class="language-sh">$ echo &gt; a
$ mkdir b
$ echo &gt; b/a
$ find . a
./a
./b/a
$ 
</code></pre>
<ol start="7">
<li>xargs 程序</li>
</ol>
<pre><code class="language-c">#include &quot;../kernel/param.h&quot;
#include &quot;user.h&quot;

int main(int argc， char *argv[]) {
  // 初始化参数列表
  char *params[MAXARG];

  // 判断xargs后的参数
  if (argc &gt; 1) {
    for (int i = 1; i &lt; argc; i++) {
      params[i - 1] = argv[i];
    }
  } else {
    printf(&quot;error\n&quot;);
    exit(1);
  }
  params[argc] = 0;

  // 从stdin读取参数，追加到参数列表最后
  // 注意这里的数组大小，若太大则可能溢出；
  char *buf[64];
  int i = 0;
  while (1) {
    int len = read(0， &amp;buf[i]， 16);
    if (len == 0 || buf[i] == (char *)'\n') {
      break;
    }
    i++;
  }
  buf[i] = 0;

  params[argc - 1] = (char *)buf;

  // 建立子进程，主进程等待
  if (fork() == 0) {
    exec(params[0]， params);
  } else {
    wait(0);
  }
  exit(0);
}
</code></pre>
<p>结果如下：</p>
<pre><code class="language-sh">$ echo hello too | xargs echo bye
bye hello to
</code></pre>
<h2 id="2-"><a class="anchor" href="#2-">#</a> 2 系统结构与系统调用</h2>
<h3 id="21-"><a class="anchor" href="#21-">#</a> 2.1 操作系统隔离性</h3>
<h4 id="heading-4"><a class="anchor" href="#heading-4">#</a> 为何需要隔离性</h4>
<ol>
<li>应用程序之间需要隔离性：在操作系统上运行的应用不应该不必要地影响其他正在运行的应用程序。</li>
<li>应用程序和操作系统之间需要隔离性：应用程序的崩溃不应该导致整个操作系统崩溃，要求操作系统有处理异常的能力。</li>
</ol>
<h4 id="heading-5"><a class="anchor" href="#heading-5">#</a> 操作系统隔离性的实现</h4>
<p>操作系统通过抽象阻止应用程序直接访问硬件资源，如进程是 CPU 的抽象、文件是磁盘的抽象。借助操作系统的抽象接口，能够实现多个应用程序复用计算机硬件资源，同时满足强隔离性的目的。</p>
<h3 id="22-"><a class="anchor" href="#22-">#</a> 2.2 操作系统防御性</h3>
<h4 id="heading-6"><a class="anchor" href="#heading-6">#</a> 为何需要防御性</h4>
<ol>
<li>操作系统需要应对恶意应用程序，防止恶意应用程序使操作系统崩溃。</li>
<li>操作系统应当保持对应用程序隔离，防止应用程序获取内核权限从而控制硬件资源。</li>
</ol>
<p>操作系统防御性是隔离性的表现之一。操作系统借助硬件支持，包括用户/内核态（user/kernel mode）和 page table（页表，或虚拟内存）实现强隔离。</p>
<h3 id="23-"><a class="anchor" href="#23-">#</a> 2.3 硬件对于强隔离的支持</h3>
<p>硬件对于强隔离的支持包括：user/kernel mode 和 page table。</p>
<h4 id="userkernel-mode"><a class="anchor" href="#userkernel-mode">#</a> user/kernel mode</h4>
<p>处理器具有两种操作状态：当运行在用户态时，只能够执行普通权限指令；当运行在内核态时，能够执行特殊权限指令。</p>
<p>普通权限指令包括寄存器的加减、跳转操作；特殊权限指令与硬件状态相关，如设置 page table 寄存器和控制时钟中断。</p>
<p>假如应用程序打算执行一条特殊权限指令，会由于用户态而拒绝执行。这时 CPU 会跳转到内核态，并且杀掉进程。</p>
<p>对于 RISC-V，处理器还具有第三种状态：机器态（machine mode）。机器态拥有最高的特权级别，能够执行任何指令，主要用于处理器初始化和异常/中断处理。</p>
<h4 id="heading-7"><a class="anchor" href="#heading-7">#</a> 虚拟内存</h4>
<p>page table 提供了虚拟内存地址和物理内存地址的对应关系。每一个独立进程都维护着一个独立的 page table，保证其物理内存地址不重叠，使其无法访问到其他应用程序的内存，从而保证了内存的隔离性。</p>
<h3 id="heading-8"><a class="anchor" href="#heading-8">#</a> 用户态/内核态切换</h3>
<p>用户态和内核态划定了用户空间和内核空间的界线：应用程序运行在用户空间，而内核程序运行在内核空间。</p>
<p>应用程序通过系统调用转移控制权给内核。在 RISC-V 中，通过 ECALL 指令转移控制权。</p>
<pre><code class="language-asm">ecall &lt;uint&gt;
</code></pre>
<p>ECALL 接受一个数字，可跳转到内核中特定的系统调用接入点。应用程序通过 syscall 函数发起系统调用，syscall 调用 ECALL，从而完成用户态/内核态切换。</p>
<h3 id="24-"><a class="anchor" href="#24-">#</a> 2.4 宏内核与微内核</h3>
<h4 id="tcb"><a class="anchor" href="#tcb">#</a> TCB</h4>
<p>TCB 即被信任的计算空间（Trusted Computing Base），代指安全的内核。一个安全的内核应当具有以下特征：</p>
<ol>
<li>内核应当具有尽可能少的漏洞。</li>
<li>内核应当认为所有应用程序都是恶意的。</li>
</ol>
<p>所有敏感的操作都应当运行在内核态，也就是 TCB 当中。</p>
<h4 id="heading-9"><a class="anchor" href="#heading-9">#</a> 宏内核</h4>
<p>所有操作系统服务均运行在内核态，这样的操作系统内核称为宏内核。绝大多数的 Unix 操作系统均是宏内核。</p>
<ul>
<li>Pro：宏内核组件具有良好的集成性，因此具有不错的性能</li>
<li>Cron：由于服务都运行在内核中，宏内核发生故障的可能性更大。</li>
</ul>
<h4 id="heading-10"><a class="anchor" href="#heading-10">#</a> 微内核</h4>
<p>微内核只在内核中提供了最基本的服务，以减少内核中的代码量。在微内核中，原本由内核提供的服务现在以一个用户程序的形式运行。</p>
<ul>
<li>Pro：微内核代码量少，发生 Bug 的可能性更低，因此更加安全。</li>
<li>Cron：需要在用户态和内核态之间反复跳转，也同时更难共享内存，从而带来性能损耗。</li>
</ul>
<h3 id="25-"><a class="anchor" href="#25-">#</a> 2.5 编译运行内核</h3>
<h4 id="xv6-"><a class="anchor" href="#xv6-">#</a> xv6 的代码结构</h4>
<ul>
<li>kernel：kernel 中包含了所有内核代码，这些代码编译成一个名叫 kernel 的二进制文件，该二进制文件运行在内核态中。</li>
<li>user：user 中包含了所有的用户程序。</li>
<li>mkfs：mkfs 创建一个空的文件镜像，通过挂载到磁盘上得到一个空的文件系统。</li>
</ul>
<h4 id="heading-11"><a class="anchor" href="#heading-11">#</a> 内核编译过程</h4>
<ol>
<li>编译：对每个. c 文件经编译器得到. s，这是 RISC-V 汇编代码文件</li>
<li>汇编：对. s 文件调用汇编器，形成. o，这是汇编代码的二进制形式</li>
<li>链接：使用系统加载器（Loader）链接成内核文件 kernel</li>
</ol>
<blockquote>
<p>这里所说的系统加载器也就是链接器（Linker）</p>
</blockquote>
<h3 id="26-xv6-"><a class="anchor" href="#26-xv6-">#</a> 2.6 xv6 启动过程</h3>
<blockquote>
<p>这部分内容比较零碎，由 claude 进行总结，我只是进行了一些整理和调整</p>
</blockquote>
<ol>
<li>XV6 的入口地址是 <code>0x80000000</code>， 这个地址是 QEMU 要求的硬性条件， XV6 的载入器 <code>kernel.ld</code> 会将内核加载到这个地址开始。</li>
<li>XV6 首先在 <code>entry.s</code> 中启动，此时还没有内存分页和进程隔离，处于 machine mode。XV6 会尽快切换到 supervisor mode。</li>
<li>其他初始化工作：
<ul>
<li>consoleinit: 初始化控制台，用于后续打印输出；</li>
<li>kinit: 初始化页表分配器；</li>
<li>kvminit: 初始化虚拟内存管理</li>
<li>kvminithart: 打开页表</li>
<li>processinit: 初始化进程表</li>
<li>trapinit/trapinithart: 初始化用户/内核模式切换</li>
<li>plicinit/plicinithart: 初始化中断控制器 PLIC</li>
<li>binit: 初始化缓冲区缓存</li>
<li>iinit: 初始化 inode 缓存</li>
<li>fileinit: 初始化文件系统</li>
<li>virtio_disk_init: 初始化磁盘</li>
</ul>
</li>
<li>userinit: 创建初始进程，并返回用户空间。这个初始进程定义在 initcode 中，它发起第一个系统调用，通过 exec 调用 init 程序。exec 系统调用由 sys_exec 函数处理，它将从用户空间读取参数并启动 init 进程。</li>
<li>init 进程配置控制台，调用 fork 启动 shell。</li>
<li>最后 shell 被执行，XV6 启动完成。</li>
</ol>
<p>所以，XV6 的启动过程可以概括为: 执行一系列初始化函数配置系统环境 -&gt; userinit 启动第一个用户进程 -&gt; 该进程执行 exec 系统调用启动 init 进程 -&gt; init 进程 fork 出 shell 进程 -&gt; shell 被执行，系统启动完成。</p>
<h2 id="lab2"><a class="anchor" href="#lab2">#</a> Lab2</h2>
<h3 id="system-call-tracing"><a class="anchor" href="#system-call-tracing">#</a> System call tracing</h3>
<ol>
<li>添加文件到 makefile</li>
</ol>
<pre><code class="language-makefile">	$U/_trace\
</code></pre>
<ol start="2">
<li>在<code>user/user.h</code>声明函数头文件；在<code>user/usys.pl</code>中添加存根；在<code>kernel/syscall.h</code>中添加系统调用的数值代号</li>
</ol>
<pre><code class="language-c">// user/user.h
int trace(int);

// user/usys.pl
entry(&quot;trace&quot;);

// kernel/syscall.h
#define SYS_trace  22
</code></pre>
<ol start="3">
<li>在 <code>kernel/syscall.c</code> 中添加声明；修改 <code>kernel/proc.c</code> 中的 proc 结构体，增加一个 mask 字段；在 <code>kernel/sysproc.c</code> 中实现 <code>sys_trace()</code> 函数。</li>
</ol>
<pre><code class="language-c">// syscall.c
extern uint64 sys_trace(void);

static uint64 (*syscalls[])(void) = {
...
    [SYS_trace] sys_trace,
};

// proc.c
struct proc {
...
  int mask;
};

// sysproc.c
uint64 sys_trace(void) {
  int mask;
  //从寄存器中取值
  if (argint(0, &amp;mask) &lt; 0) {
    return -1;
  }
  myproc()-&gt;mask = mask;
  return 0;
}
</code></pre>
<ol start="4">
<li>修改 <code>kernel/proc.c</code>中的<code>fork</code>函数，以从父进程复制到子进程的跟踪掩码</li>
</ol>
<pre><code class="language-c">//proc.c
int fork(void){
  ...
  np-&gt;mask = p-&gt;mask;
  ...
}
</code></pre>
<ol start="5">
<li>修改 <code>kernel/syscall.c</code> 中的 <code>syscall</code> 函数，打印输出</li>
</ol>
<pre><code class="language-c">void
syscall(void)
{
  int num;
  struct proc *p = myproc();

  num = p-&gt;trapframe-&gt;a7;
  if(num &gt; 0 &amp;&amp; num &lt; NELEM(syscalls) &amp;&amp; syscalls[num]) {
    p-&gt;trapframe-&gt;a0 = syscalls[num]();
    if ((1 &lt;&lt; num) &amp; p-&gt;mask) {
      printf(&quot;%d: syscall %s -&gt; %d\n&quot;, p-&gt;pid, syscalls[num], p-&gt;trapframe-&gt;a0);
    }
  } else {
    printf(&quot;%d %s: unknown sys call %d\n&quot;,
            p-&gt;pid, p-&gt;name, num);
    p-&gt;trapframe-&gt;a0 = -1;
  }
}
</code></pre>
<h3 id="sysinfo"><a class="anchor" href="#sysinfo">#</a> Sysinfo</h3>
<h2 id="3-"><a class="anchor" href="#3-">#</a> 3 虚拟内存</h2>
<p>虚拟内存是对物理内存的抽象，它提供虚拟地址空间到物理地址的映射，是计算机隔离性的重要环节之一。</p>
<p>现代计算机均通过某种方式对虚拟内存提供了硬件支持。</p>
<h3 id="31-"><a class="anchor" href="#31-">#</a> 3.1 地址空间</h3>
<h4 id="heading-12"><a class="anchor" href="#heading-12">#</a> 地址空间的必要性</h4>
<p>程序必须存在于物理内存当中，假若不具有隔离性，很可能会破坏其他应用程序甚至操作系统的正常运作。我们通过向每个程序提供独立的地址空间来实现必要的隔离性。</p>
<h3 id="32-"><a class="anchor" href="#32-">#</a> 3.2 页表</h3>
<h4 id="heading-13"><a class="anchor" href="#heading-13">#</a> 如何创建地址空间</h4>
<p>我们通过页表创建独立的地址空间。页表在硬件中通过处理器和内存管理单元实现。</p>
<p>对任何涉及地址的指令，其使用的均是虚拟地址。虚拟地址会被转到内存管理单元（MMU，Memory Management Unit）并翻译成物理地址，由得到的物理地址去索引物理内存。</p>
<h4 id="mmu-"><a class="anchor" href="#mmu-">#</a> MMU 如何翻译虚拟地址</h4>
<p>为了完成虚拟地址到物理地址的映射，MMU 需要在内存中保存一份表单，表单地址保存在 CPU 的寄存器中（在 RISC-V 中是 SATP 寄存器）。</p>
<p>每一个应用程序应当保存了一份自己的表单，在切换应用程序中，SATP 中的内容也必须做相应的切换。</p>
<h4 id="risc-v-"><a class="anchor" href="#risc-v-">#</a> RISC-V 中虚拟内存的实现</h4>
<p>虚拟地址和表单不是一对一的关系。在 RISC-V 中，一个 page 的大小是 4KB。</p>
<p>对于一个虚拟地址，它的内容分为 index 和 offset 两部分。MMU 通过 index 找到物理内存 page 号，通过 page 起始地址加上偏移量从而找到物理地址。</p>
<p>RISC-V 寄存器是 64 位，最大支持 64 位虚拟地址；但高 25 位并未使用，因此最大支持 2^39，即 512G 内存。其中 27 位作为 index，12 位作为 offset，对应 page 的 4096 字节。</p>
<p>RISC-V 最大支持 56 位物理地址，因此最大内存理论上最多能够到达 2^56 字节。其中 44 位物理 page 号，12 位 offset（直接从虚拟地址中拷贝）。</p>
<p>在 RISC-V 中，page-table 是一个多级结构。</p>
<p><img src="https://906337931-files.gitbook.io/~/files/v0/b/gitbook-legacy-files/o/assets%2F-MHZoT2b_bcLghjAOPsJ%2F-MKKjB2an4WcuUmOlE__%2F-MKPwJezGQDkWaLDRuDs%2Fimage.png?alt=media&amp;token=654cbddc-fab3-4180-8bd7-d275c63ae67f" alt=""></p>
<p>虚拟地址的 27 位 index 又细分为 L2、L1、L0，依次对应高、中、低级 page directory。每级 page directory 索引 512 个条目，每个条目（PTE）占 8 字节。在索引时，从高到低依次索引，然后在最低级的 page directory 中可得到实际物理地址。</p>
<p>分级结构很容易理解：通过将一个大的表单拆分多个小的表单，我们可以不索引许多没有用到的PTE，从而大大减少了内存开销。</p>
<p>一个 page directory 分为 44 位 PPN（page 起始地址）和 10 位标志位，其他 10 位作为拓展位留空。标志位包括：</p>
<ol>
<li>Valid：表明 PTE 是否合法，合法（被使用）的 Valid 置一，否则置零。</li>
<li>Readable 和 Writable，表明是否可读写 page</li>
<li>Executable：是否可从该 page 执行指令</li>
<li>User：是否可被用户空间进程访问</li>
<li>其他：不重要</li>
</ol>
<h3 id="33-"><a class="anchor" href="#33-">#</a> 3.3 页表缓存</h3>
<p>三级寻址需要三次内存读取，因此代价较高，所以需要缓存最近读取过的内存地址，该技术称为页表缓存（TLB，Translation Lookside Buffer）。</p>
<p>TLB 会保存查询到的虚拟地址到物理地址的映射关系，在下一次访问同一虚拟地址时可直接从 TLB 中查取，从而避免查询 page table。在 table page 切换后 TLB 也会清空（RISC-V 中通过 sfence_vma 指令）。</p>
<h3 id="34-xv6-"><a class="anchor" href="#34-xv6-">#</a> 3.4 xv6 页表实现</h3>
<h4 id="heading-14"><a class="anchor" href="#heading-14">#</a> 物理内存分布</h4>
<p>物理地址寻址由具体主板决定，一般来说，从某个物理地址分隔（教程中是 0x80000000），以上是从 DRAM 寻址，以下是 I/O 设备。</p>
<p><img src="https://906337931-files.gitbook.io/~/files/v0/b/gitbook-legacy-files/o/assets%2F-MHZoT2b_bcLghjAOPsJ%2F-MK_UbCc81Y4Idzn55t8%2F-MKaeaT3eXOyG4jfKKU7%2Fimage.png?alt=media&amp;token=a04af08d-3c8d-4c61-a63d-6376dec252ea" alt=""></p>
<p>上电后，主板运行 boot ROM 中的代码，然后跳转到 0x80000000，从而启动操作系统。</p>
<h4 id="xv6--1"><a class="anchor" href="#xv6--1">#</a> xv6 虚拟地址空间</h4>
<p>处于简单考虑，在 xv6 中，虚拟地址和物理地址的映射是相等映射。但是，虚拟地址和物理地址之间的映射关系可能是一对一、一对多、多对一。</p>
<p>我们还可以为 page table 设置权限，从而提早发现和处理 bug。</p>
<h3 id="35-kvminit-"><a class="anchor" href="#35-kvminit-">#</a> 3.5 kvminit 函数</h3>
<p>kvminit 函数设置地址空间。其结构如下：</p>
<p><img src="https://906337931-files.gitbook.io/~/files/v0/b/gitbook-legacy-files/o/assets%2F-MHZoT2b_bcLghjAOPsJ%2F-MKgiYv2CppKnuZEsKO3%2F-MKjcMW3TzZ3kdPwse0X%2Fimage.png?alt=media&amp;token=080b793a-f859-479b-aa53-20dec81d4e88" alt=""></p>
<ol>
<li>代码的最上方为最高级 page 分配内存，并将内存置零</li>
<li><code>kvmmap</code> 函数将 I/O 设备映射到内核</li>
<li>vmprint 打印当前的 kernel page table</li>
</ol>
<h3 id="36-kvminithart-"><a class="anchor" href="#36-kvminithart-">#</a> 3.6 kvminithart 函数</h3>
<p>kvminithart 函数运行在 kvminit 函数之后。</p>
<p><img src="https://906337931-files.gitbook.io/~/files/v0/b/gitbook-legacy-files/o/assets%2F-MHZoT2b_bcLghjAOPsJ%2F-MKgiYv2CppKnuZEsKO3%2F-MKjffmTgmjxQO-BCcin%2Fimage.png?alt=media&amp;token=050d4673-2526-43c7-83aa-6b623e840074" alt=""></p>
<p>kvminithart 的作用是告知内核使用已经设置好的 page table，在此之后虚拟内存开始工作。</p>
<h2 id="4-risc-v-"><a class="anchor" href="#4-risc-v-">#</a> 4 RISC-V 调用约定和栈结构</h2>
<h3 id="41-c-"><a class="anchor" href="#41-c-">#</a> 4.1 C 程序到汇编的转换</h3>
<p>C 程序无法直接被计算机理解。计算机能够理解的是二进制代码，或者说 ISA（指令集）所对应的汇编语言。因此，需要将 C 程序经过编译（包括编译、汇编、链接等）变成汇编语言。</p>
<h3 id="42-risc-v--x86"><a class="anchor" href="#42-risc-v--x86">#</a> 4.2 RISC-V 和 x86</h3>
<p>RISC-V 是一种精简指令集（RISC，Reduced Instruction Set Computer），而 x86 是复杂指令集（CISC，Complex Instruction Set Computer）。两者主要区别如下：</p>
<ol>
<li>RISC-V 指令数量远小于 x86，x86存在历史包袱；</li>
<li>RISC-V 指令更加简单（封装程度低）；</li>
<li>RISC-V 是唯一的开源指令集；</li>
</ol>
<h3 id="43-risc-v-"><a class="anchor" href="#43-risc-v-">#</a> 4.3 RISC-V 寄存器</h3>
<p>RISC-V寄存器结构如下：</p>
<p><img src="https://906337931-files.gitbook.io/~/files/v0/b/gitbook-legacy-files/o/assets%2F-MHZoT2b_bcLghjAOPsJ%2F-MM-XjiGboAFe-3YvZfT%2F-MM0rYc4eVnR9nOesAAv%2Fimage.png?alt=media&amp;token=f30ebac8-8dc0-4b5d-8aa7-b241a10b43b3" alt=""></p>
<p>汇编代码运行在寄存器上，寄存器是运算和数据读取的最快方式。</p>
<p>第一列寄存器名称只在 Compressed Instruction（16bit）中有用，在其他地方使用 ABI 名称进行调用。</p>
<p>a0-7 寄存器保存函数参数，当参数数量大于寄存器数量时需要使用内存，因此会降低效率。</p>
<p>我们可以从 Saver 列查看寄存器的 Saver 类型，它有两个可能的值：Caller 和 Callee。其中 Caller 寄存器在函数调用时不会保存，也就是说它可以被调用函数重写。</p>
<h3 id="44-"><a class="anchor" href="#44-">#</a> 4.4 栈</h3>
<p>每次调用函数都会产生一个栈帧。它通过栈指针分配内存。由于栈帧是从高地址到低地址，因此当创建一个栈帧时对地址做减法。</p>
<p><img src="https://906337931-files.gitbook.io/~/files/v0/b/gitbook-legacy-files/o/assets%2F-MHZoT2b_bcLghjAOPsJ%2F-MM3Hk7Gv6ibvM2lxjCc%2F-MM4D2J3t3ajqkngxRPC%2Fimage.png?alt=media&amp;token=1f78ffd1-9322-4666-85f2-8aa831ced49e" alt=""></p>
<p>栈帧中有两个重要的寄存器：fp 指向栈帧顶部，sp 指向栈帧底部。</p>
<p>一个栈帧中的第一位保存着自己的返回地址，然后是指向前一个栈帧的指针，以便函数返回。返回地址保存在 sp 寄存器中，指向前一个栈帧的指针保存在 fp 寄存器中。</p>
<p><img src="https://906337931-files.gitbook.io/~/files/v0/b/gitbook-legacy-files/o/assets%2F-MHZoT2b_bcLghjAOPsJ%2F-MM4GlTfQa57FRIbUhP2%2F-MM57e54ANIFdXpVubXH%2Fimage.png?alt=media&amp;token=e9b9b85d-5862-4825-8b7c-7be342636a77" alt=""></p>
<p>上面的函数调用了一个名为 <code>sum_to</code> 的函数，因此必须包含 prologue：首先将 sp 寄存器减 16 以创建一个新的栈帧，然后将返回地址保存在 sp。</p>
<p><img src="https://906337931-files.gitbook.io/~/files/v0/b/gitbook-legacy-files/o/assets%2F-MHZoT2b_bcLghjAOPsJ%2F-MM4GlTfQa57FRIbUhP2%2F-MM58TOs_9kQtfl4bVPw%2Fimage.png?alt=media&amp;token=9fd14608-4f97-4fef-9ef7-4df05502fd5a" alt=""></p>
<p>在函数调用的最后加载返回地址到 ra 寄存器，然后对栈指针加 16 以删除创建的栈帧。</p>
<h3 id="45-"><a class="anchor" href="#45-">#</a> 4.5 结构体的结构</h3>
<p>结构体在内存中是一段连续的地址，类似于一个数组，但每个字段的类型不需要相同。</p>
<h2 id="5-"><a class="anchor" href="#5-">#</a> 5 隔离与系统调用的进入和退出</h2>
<h3 id="51-trap"><a class="anchor" href="#51-trap">#</a> 5.1 Trap</h3>
<p>用户空间和内核空间的切换成为 trap，它发生在：</p>
<ol>
<li>系统调用</li>
<li>发生 page fault 或除零错误</li>
<li>中断</li>
</ol>
<h4 id="trap-"><a class="anchor" href="#trap-">#</a> trap 流程</h4>
<ol>
<li>保存 32 个用户寄存器，以便在调用完成后恢复原来状态</li>
<li>保存 pc （程序寄存器）</li>
<li>更改 mode 标志位为 supervisor mode，以读写控制寄存器</li>
<li>SATP 寄存器保存 page table 的物理地址，需要将其从 user page table 切换到 kernel page table</li>
<li>将堆栈寄存器（fp、sp）指向内核中的地址以调用内核代码</li>
<li>跳转到内核空间</li>
</ol>
<h3 id="52-trap-"><a class="anchor" href="#52-trap-">#</a> 5.2 Trap 代码执行流程</h3>
<p>以 write 函数为例，它调用 ecall 切换到内核空间：</p>
<ol>
<li>调用 uservec 函数</li>
<li>调用 usertrap 函数</li>
<li>执行 syscall，找到并调用 sys_write，打印到控制台并返回到 usertrap 函数</li>
<li>usertrap 在最后执行 usertrapret，完成返回用户空间的部分准备工作</li>
<li>执行 userret 函数</li>
</ol>
<h2 id="6-page-faults"><a class="anchor" href="#6-page-faults">#</a> 6 Page faults</h2>
<h3 id="61-page-fault-"><a class="anchor" href="#61-page-fault-">#</a> 6.1 page fault 基础</h3>
<p>虚拟内存的主要优点是：虚拟内存提供了应用之间以及用户空间与内核空间之间的隔离性；另外，虚拟内存提供了一层抽象，实现了虚拟地址和物理地址之间的动态映射。</p>
<p>page fault 能够动态更新 page table，我们能够利用 page fault 进行一些操作系统的优化行为。响应 page fault 需要记录以下几个信息：</p>
<ol>
<li>触发 page fault 的源，也就是引起错误的虚拟内存地址。当 page fault 被触发，会进入 trap，并将错误地址保存在 STVAL 寄存器中。</li>
<li>出错的原因。即 trap 中状态切换的原因，用数字代号表示，保存在 SCAUSE 寄存器中。</li>
<li>触发 page fault 的指令地址，即发生错误的程序计数器的值，标志 page fault 在用户空间发生的位置，以便修复 page table 后可以恢复中断的指令。存储在 SEPC 寄存器以及 <code>trapframe-&gt;epc</code> 中。</li>
</ol>
<h3 id="62-"><a class="anchor" href="#62-">#</a> 6.2 懒内存分配</h3>
<p><img src="https://906337931-files.gitbook.io/~/files/v0/b/gitbook-legacy-files/o/assets%2F-MHZoT2b_bcLghjAOPsJ%2F-MMSxponnGmjT-9o9zTI%2F-MMSxrQomWtds7XdFzKH%2Fimage.png?alt=media&amp;token=e580c883-0c0a-4370-852e-393c05cd2fc1" alt=""></p>
<p>在 RISC-V 中使用 sbrk 系统调用进行应用程序的内存分配。在应用程序启动时，sbrk 指向 heap 的底部，也就是 stack 的顶部，由 p-&gt;sz 标志。sbrk 接受一个整数参数，指示分配的字节数（页数？），以扩大 heap。</p>
<p>sbrk 默认的机制是 eager allocation，即积极的分配策略，在调用时立刻分配内存。但这非常容易造成内存浪费的问题。因此我们可以利用 page fault 实现 lazy allocation。</p>
<p>懒分配是指不立即分配内存，而是在发生由于内存未分配造成的 page fault 时执行 handler：使用 kalloc 分配一个内存 page，使用 0 填充内容以初始化并映射到 user page table，然后重新执行指令。</p>
<p>原始的 sbrk 函数如下，它将 <code>p-&gt;sz</code> 加 n 并分配内存：</p>
<p><img src="https://906337931-files.gitbook.io/~/files/v0/b/gitbook-legacy-files/o/assets%2F-MHZoT2b_bcLghjAOPsJ%2F-MMhf55_kv7MwKoDReP9%2F-MMi5nltOEPL47k3aWDy%2Fimage.png?alt=media&amp;token=d30677d3-76c2-4899-904d-1c888014dd92" alt=""></p>
<p>而我们只想让其加 n，但不分配内存：</p>
<p><img src="https://906337931-files.gitbook.io/~/files/v0/b/gitbook-legacy-files/o/assets%2F-MHZoT2b_bcLghjAOPsJ%2F-MMhf55_kv7MwKoDReP9%2F-MMi6ZfF398jK09BDzuh%2Fimage.png?alt=media&amp;token=132d7da6-0da5-466e-a3d5-4c54aafa8261" alt=""></p>
<p>这样就会如期发生 page fault，我们在 usertrap 函数中对其 (SCAUSE=15) 进行处理，为其分配内存，若无物理内存则 kill 进程：</p>
<p><img src="https://906337931-files.gitbook.io/~/files/v0/b/gitbook-legacy-files/o/assets%2F-MHZoT2b_bcLghjAOPsJ%2F-MMiBlrqE-q1_u5-VWpo%2F-MMiVmy1jHsocOlJC1gG%2Fimage.png?alt=media&amp;token=b162b795-3ed8-45c8-bac7-76c4cb5d4919" alt=""></p>
<h3 id="63-zero-fill-on-demand"><a class="anchor" href="#63-zero-fill-on-demand">#</a> 6.3 Zero-Fill-On-Demand</h3>
<p>用户程序的地址空间中存在 data、text、bss 三个区块，其中，text 存放程序指令，data 区域存放已初始化的全局变量，bss 包含未初始化或初始化为 0 的全局变量。</p>
<p>在程序初始化时，我们需要分配许多内容为 0 的 page。通过使用按需分配策略，可以只初始化一个全零的物理 page，同时将虚拟地址空间挂载到这个物理 page 之上。这个 page 应当是只读的。在尝试读写这个 page 时，会发生 page fault，我们在 handler 中新分配一个全零的 page，并重新进行操作。</p>
<p>它带来的好处是我们不需要在一开始就为应用程序分配大量内存，它能够减少内存的用量，同时加快应用程序的启动速度。但是 page fault 处理会增加一定成本。</p>
<h3 id="64-cow-fork"><a class="anchor" href="#64-cow-fork">#</a> 6.4 COW Fork</h3>
<p>COW Fork 即 Copy-On-Write Fork，它使用写时复制策略。它尝试解决的问题是：当我们同时调用 fork 和 exec 时，fork 会创建新的 page，并将父进程的 page 拷贝到子进程 page 当中；但执行 exec 后，它又会抛弃这些 page（也就是说这部分内存不会被修改），并分配新的 page 来执行新的指令内容。</p>
<p>COW Fork 所做的就是让子进程共享父进程物理内存 page，也就是设置子进程的 PTE 指向父进程的物理内存 page。出于隔离性考虑，我们将子进程和父进程的 PTE 均设置为只读。因此，当尝试更改内存内容时会发生 page fault。这时可以为子进程创建新的 page，该 page 只对子进程可见，而原 page 对父进程可读写。</p>
<h3 id="65-demanding-paging"><a class="anchor" href="#65-demanding-paging">#</a> 6.5 Demanding Paging</h3>
<p>在 exec 执行后，需要加载内存的 data 和 text 到 page 中。操作系统默认使用 eager 的方式进行加载。demanding paging 也就是事先在虚拟空间中分配好 data 和 text 的地址段，但不对应任何实际的物理地址，即将 PTE 的 valid bit 设为 0。</p>
<p>当应用程序从地址 0 开始执行，当遇到 on-demand page 时会触发 page fault，这时我们从内存中读取程序 page 数据，然后将其映射到 page table 再重新执行。</p>
<p>当不是全部的 data 和 text 被用到时，通过这种方式我们可以节省内存的使用，同时加快程序的运行速度。</p>
<p>当物理内存耗尽时，一种方法是撤回 page，也就是将其写回文件系统，并释放该 page。</p>
<p>我们通常使用 LRU（Least Recently Used）策略决定将要撤回的 page。page 分为 dirty 和 non-dirty page：dirty page 曾经被写，而 non-dirty page 只被读过。我们比较倾向选择 non-dirty page，因为 dirty page 需要再次被写回到内存中，因而对其写的成本更高。</p>
<p>在 PTE 中的 RSW 寄存器中存有 Dirty 和 Access bit，这两个 bit 标志该 PTE 是否是 dirty 以及在何时被访问过，因此可以用 Access bit 来决定 LRU 排名。</p>
<h3 id="66-memory-mapped-files"><a class="anchor" href="#66-memory-mapped-files">#</a> 6.6 Memory Mapped Files</h3>
<p>我们会面临将文件加载到内存中对其处理的场合，由 mmap 系统调用函数提供。而使用 eager 策略将其加载到内存中的代价往往较高，因此操作系统一般采用懒加载策略。</p>
<p>mmap 接受一个虚拟地址（VA）、长度（len）、保护、标志位、文件描述符和偏移量，表示从文件描述符对应的文件的偏移量的位置开始，映射长度为 len 的内容到虚拟内存地址 VA，同时我们需要加上一些保护，比如只读或者读写。</p>
<p>具体实现中，我们使用 VMA（Virtual Memory Area）结构体保存文件描述符、偏移量等，以记录虚拟内存地址对应的实际内容位置。当发生 page fault 时，将磁盘数据读取到内存中。</p>
<h2 id="7-"><a class="anchor" href="#7-">#</a> 7 中断</h2>
<h3 id="71-"><a class="anchor" href="#71-">#</a> 7.1 真实操作系统实际内存使用情况</h3>
<p>真实操作系统中大多数内存被使用，除应用程序用量外，大多数的内存被 buff/cache 占用。当需要使用新的内存时，往往需要从已使用的内存中撤回部分内存以重新利用。</p>
<p>在实际使用中，VIRT（虚拟内存）要远大于 RES（实际使用内存），因此 demand paging 等优化很有必要。</p>
<h3 id="72-"><a class="anchor" href="#72-">#</a> 7.2 中断硬件部分</h3>
<p>当中断发生时，操作系统需要保存当前工作，处理中断，然后恢复原先的工作；在这个意义上，中断与系统调用以及 page fault 的处理很类似。但中断有其特殊性：</p>
<ol>
<li>中断与 CPU 当前执行的任务无关。</li>
<li>CPU 与中断发生的设备并行运行。</li>
</ol>
<p>外设连接到 CPU，CPU 通过 PLIC（Platform Level Interrupt Control）处理外设的中断。PLIC 路由中断到 CPU 的一个核以进行处理，当处理完毕，CPU 会通知 PLIC；当没有空闲的核时，PLIC 保留中断直至被处理。</p>
<h3 id="73-"><a class="anchor" href="#73-">#</a> 7.3 设备驱动</h3>
<p>驱动即内核中用以管理设备的代码，一般分为 bottom 和 top 两部分。</p>
<p>bottom 是中断 handler，由 CPU 调用以处理中断；top 是供用户进程及内核其他部分调用的接口。</p>
<p>驱动中存在 buffer，bottom/top 均会向 buffer 中读写数据。</p>
<p>对驱动编程即找到设备在物理地址空间上的位置，并使用 store/load 对其进行操作和控制。</p>
<h3 id="74-xv6-"><a class="anchor" href="#74-xv6-">#</a> 7.4 xv6 中的中断</h3>
<p>RISC-V 有如下与中断相关的寄存器：</p>
<ol>
<li>SIE（Supervisor Interrupt Enable），S 负责软件中断，I 负责定时器中断，E 负责外设中断。</li>
<li>SSTATUS（Supervisor Status），可用来控制关闭和打开中断</li>
<li>SIP（Supervisor Interrupt Pending），用来判断中断的类型</li>
<li>SCAUSE：标志 trap 发生原因是中断或其他</li>
<li>STVEC：trap 发生的位置，以便完成后恢复</li>
</ol>
<h4 id="heading-15"><a class="anchor" href="#heading-15">#</a> 中断处理代码</h4>
<ol>
<li><code>start</code> 函数中将中断设置在 supervisor 模式，然后设置 SIE 寄存器接收中断，再初始化定时器。</li>
</ol>
<p><img src="https://906337931-files.gitbook.io/~/files/v0/b/gitbook-legacy-files/o/assets%2F-MHZoT2b_bcLghjAOPsJ%2F-MNYn8xQ_nM7UyU1sa-g%2F-MNa5Rv4ANj0GOmpMXf9%2Fimage.png?alt=media&amp;token=99fa1a9b-b983-46ec-9c0f-616220592cd9" alt=""></p>
<ol start="2">
<li>在<code>main</code>函数中处理中断</li>
</ol>
<p><img src="https://906337931-files.gitbook.io/~/files/v0/b/gitbook-legacy-files/o/assets%2F-MHZoT2b_bcLghjAOPsJ%2F-MNYn8xQ_nM7UyU1sa-g%2F-MNa6N7vHde52fObSxUz%2Fimage.png?alt=media&amp;token=65580d62-73c5-46eb-8767-e2fde2daac36" alt=""></p>
<ol start="3">
<li>处理 consoleinit。初始化锁，然后初始化uart</li>
</ol>
<p><img src="https://906337931-files.gitbook.io/~/files/v0/b/gitbook-legacy-files/o/assets%2F-MHZoT2b_bcLghjAOPsJ%2F-MNYn8xQ_nM7UyU1sa-g%2F-MNa6mHXaOc6Dtv5U6bj%2Fimage.png?alt=media&amp;token=80ea954c-2230-4eba-adcf-1a8e386bdb4a" alt=""></p>
<ol start="4">
<li>初始化uart。关闭中断，设置波特率，设置字符长度为8，重置FIFO，开启中断。之后uart可以生成中断。</li>
</ol>
<p><img src="https://906337931-files.gitbook.io/~/files/v0/b/gitbook-legacy-files/o/assets%2F-MHZoT2b_bcLghjAOPsJ%2F-MNYn8xQ_nM7UyU1sa-g%2F-MNa7OdMH3taGmHfE7Wj%2Fimage.png?alt=media&amp;token=0538d371-3758-431d-98e6-907f5f5a6ab9" alt=""></p>
<ol start="5">
<li>初始化 plic。决定 plic 接收哪些中断并路由。</li>
</ol>
<p><img src="https://906337931-files.gitbook.io/~/files/v0/b/gitbook-legacy-files/o/assets%2F-MHZoT2b_bcLghjAOPsJ%2F-MNa7TJFrEQk2gYzkwCG%2F-MNcl8NhzO719lb6xtPl%2Fimage.png?alt=media&amp;token=ceb45ee2-8509-48fb-9166-7d6bc9930fef" alt=""></p>
<ol start="6">
<li>使用plicinithart决定对哪些中断感兴趣</li>
</ol>
<p><img src="https://906337931-files.gitbook.io/~/files/v0/b/gitbook-legacy-files/o/assets%2F-MHZoT2b_bcLghjAOPsJ%2F-MNa7TJFrEQk2gYzkwCG%2F-MNcmoGEKLSU8ifrGFC6%2Fimage.png?alt=media&amp;token=4bbb1a15-4f10-427c-961e-51b801adf8ef" alt=""></p>
<ol start="7">
<li>调用scheduler函数以设置SSTATUS寄存器，使CPU能够接受中断</li>
</ol>
<p><img src="https://906337931-files.gitbook.io/~/files/v0/b/gitbook-legacy-files/o/assets%2F-MHZoT2b_bcLghjAOPsJ%2F-MNa7TJFrEQk2gYzkwCG%2F-MNcnlTuggw_Il7m9iIW%2Fimage.png?alt=media&amp;token=ac9df287-e059-4438-957e-548f1b22e030" alt=""></p>
<p><img src="https://906337931-files.gitbook.io/~/files/v0/b/gitbook-legacy-files/o/assets%2F-MHZoT2b_bcLghjAOPsJ%2F-MNa7TJFrEQk2gYzkwCG%2F-MNcoC3QhbWZHXRz2BEt%2Fimage.png?alt=media&amp;token=eca193c8-ff3d-4d96-b837-5cfbbc2b2ecc" alt=""></p>
<h3 id="75-uart--top"><a class="anchor" href="#75-uart--top">#</a> 7.5 UART 驱动 top</h3>
<p>以 shell 输出提示符 <code>$</code> 到 console 为例：</p>
<ol>
<li>在 main 函数中同过 mkmod 系统调用创建 console，再通过 dup 创建 stdout 和 stderr，从而得到三个指向 console 的文件描述符 0、1、2。</li>
</ol>
<p><img src="https://906337931-files.gitbook.io/~/files/v0/b/gitbook-legacy-files/o/assets%2F-MHZoT2b_bcLghjAOPsJ%2F-MNa7TJFrEQk2gYzkwCG%2F-MNcplHF86eYTpFW_ztO%2Fimage.png?alt=media&amp;token=e445273b-fd4d-4b8f-ad9a-100f621a2b62" alt=""></p>
<ol start="2">
<li>shell 打开 console 的文件描述符，向文件描述符 2 打印 <code>$</code>。</li>
</ol>
<p><img src="https://906337931-files.gitbook.io/~/files/v0/b/gitbook-legacy-files/o/assets%2F-MHZoT2b_bcLghjAOPsJ%2F-MNa7TJFrEQk2gYzkwCG%2F-MNcqqRtbogpSiiEpc2P%2Fimage.png?alt=media&amp;token=a1ae7eb6-b01d-4886-93ba-771f0bbe4182" alt=""></p>
<ol start="3">
<li>上一步中的 <code>fprintf</code> 发起系统调用 <code>write</code>，由 <code>filewrite</code> 判断是设备类型，最终调用 <code>consolewrite</code> 函数。<code>either_copyin</code> 拷入字符，使用 <code>uartputc</code> 写给 UART 设备。</li>
</ol>
<p><img src="https://906337931-files.gitbook.io/~/files/v0/b/gitbook-legacy-files/o/assets%2F-MHZoT2b_bcLghjAOPsJ%2F-MNa7TJFrEQk2gYzkwCG%2F-MNctcQci75CDpfVpdRq%2Fimage.png?alt=media&amp;token=08880b86-4d8f-4b67-aa3c-cc5ce6cb17b0" alt=""></p>
<ol start="4">
<li>uart中定义了一个环形buffer。<code>uartputc</code>函数中先判断环形buffer是否已满，若已满则sleep一段时间以让出CPU，否则将数据写入buffer，然后调用<code>uartstart</code>函数。</li>
</ol>
<p><img src="https://906337931-files.gitbook.io/~/files/v0/b/gitbook-legacy-files/o/assets%2F-MHZoT2b_bcLghjAOPsJ%2F-MNa7TJFrEQk2gYzkwCG%2F-MNcudamCocCj7PtfYpv%2Fimage.png?alt=media&amp;token=f9ff4004-3b5d-4c5a-bbf2-676d10dc2033" alt=""></p>
<p><img src="https://906337931-files.gitbook.io/~/files/v0/b/gitbook-legacy-files/o/assets%2F-MHZoT2b_bcLghjAOPsJ%2F-MNa7TJFrEQk2gYzkwCG%2F-MNcu9oxFUI2qpie5z4T%2Fimage.png?alt=media&amp;token=b0201ce3-225c-4696-a5e4-348e1b081bcc" alt=""></p>
<ol start="5">
<li><code>uartstart</code>通知设备执行操作。首先检测设备是否空闲，若空闲则从buffer中读取数据并写入THR（Transmission Holding Register）寄存器以发送数据。当数据到达设备，系统调用返回。</li>
</ol>
<p><img src="https://906337931-files.gitbook.io/~/files/v0/b/gitbook-legacy-files/o/assets%2F-MHZoT2b_bcLghjAOPsJ%2F-MNcv-xytcPNjgcA09N-%2F-MNfDMD08BsxVVcKpVl3%2Fimage.png?alt=media&amp;token=58e70d9b-7dd2-46bb-8243-bb188dcb8307" alt=""></p>
<h3 id="76-uart-bottom"><a class="anchor" href="#76-uart-bottom">#</a> 7.6 UART驱动 bottom</h3>
<p>当一个中断由 PCIE 发送给 CPU：</p>
<ol>
<li>清楚 SIE 相应位的 bit，以防止被其他中断打断。</li>
<li>设置 SEPT 寄存器为当前 pc，以便之后恢复</li>
<li>保存当前 mode（如 user mode）</li>
<li>将 mode 设置为 Supervisor mode</li>
<li>将 pc 置为 STVEC 的值（即 trap 处理程序的地址），进入usertrap</li>
<li><code>usertrap</code> 调用 <code>devintr</code>，通过 SCAUSE 判断是否来自外设的中断，然后使用 <code>plic_claim</code> 获取中断。</li>
</ol>
<p><img src="https://906337931-files.gitbook.io/~/files/v0/b/gitbook-legacy-files/o/assets%2F-MHZoT2b_bcLghjAOPsJ%2F-MNfH5qMvmyxhegTFSUo%2F-MNpcUmolzUjQhGtVWpo%2Fimage.png?alt=media&amp;token=a894536b-a241-4230-8c0e-300d556275b6" alt=""></p>
<ol start="7">
<li><code>plic_clame</code> 函数中 CPU 告知 PLIC 自己要处理中断，返回中断号</li>
</ol>
<p><img src="https://906337931-files.gitbook.io/~/files/v0/b/gitbook-legacy-files/o/assets%2F-MHZoT2b_bcLghjAOPsJ%2F-MNfH5qMvmyxhegTFSUo%2F-MNpdQCYQP1Gcv_HTm7o%2Fimage.png?alt=media&amp;token=3dca463c-486f-4c96-87da-bc8401a65e94" alt=""></p>
<ol start="8">
<li>若接收到的是 UART 中断，则调用 <code>uartintr</code> 函数，从 UART 的接受寄存器中读取数据，然后将数据传给 <code>consoleintr</code></li>
</ol>
<p><img src="https://906337931-files.gitbook.io/~/files/v0/b/gitbook-legacy-files/o/assets%2F-MHZoT2b_bcLghjAOPsJ%2F-MNfH5qMvmyxhegTFSUo%2F-MNpeCI5zYrIAIDEUzeD%2Fimage.png?alt=media&amp;token=796177bb-eeb4-45d8-8502-2c60fac1b5ec" alt=""></p>
<h3 id="77-"><a class="anchor" href="#77-">#</a> 7.7 中断相关并发</h3>
<p>中断相关的并发包括以下几类：</p>
<ol>
<li>设备与 CPU 并行。称为 producer-consumer 并行。</li>
<li>中断停止当前程序运行。中断不仅会打断用户空间代码，也有可能打断内核空间代码，而内核空间代码某些不应该被打断。</li>
<li>驱动的 top 和 bottom 并行执行。这也意味着它们可以在两个 CPU 上执行，需要通过锁来共享数据。</li>
</ol>
<p>驱动中包含一个环形buffer，大小为32个字节，它有两个指针：读指针和写指针。当向buffer中写入数据时写指针加，读数据时读指针加；两指针相等时表示buffer是空的。</p>
<p>producer-consumer 并发中，producer（在示例中是 uartputc）可以一直向 buffer 中写入数据，直到 buffer 满了，暂时 sleep；consumer，即中断 handler 函数（在示例中是 uartintr）当发生中断时从 buffer 中读数据，直到 buffer 为空。</p>
<h3 id="78-"><a class="anchor" href="#78-">#</a> 7.8 中断的演进</h3>
<p>当一个快设备的场合，中断发生过快以至超出 CPU 的处理能力，这时我们往往使用 polling（轮询）；而对慢设备使用中断。在一些场合可以动态切换轮询和中断（如网卡的 NAPI）。</p>
<h2 id="8-"><a class="anchor" href="#8-">#</a> 8 多线程和锁</h2>
<h3 id="81-"><a class="anchor" href="#81-">#</a> 8.1 为什么要使用锁</h3>
<h4 id="heading-16"><a class="anchor" href="#heading-16">#</a> 为何我们倾向于使用多线程提高性能</h4>
<p>自2000年开始，CPU的时钟频率几乎不再增加，因此CPU的单线程达到了一个极限；而CPU的晶体管数量持续增加，因此我们倾向使用多核的方式提高计算机性能。</p>
<h4 id="heading-17"><a class="anchor" href="#heading-17">#</a> 锁的优缺点</h4>
<p>当我们同时使用多个核时，需要使用锁来协调多线程时数据的更新，以确保共享数据的正确性以及避免 race condition 的发生。</p>
<p>但是锁同时也会带来性能损失，使程序再次变成串行。</p>
<h3 id="82--race-condition"><a class="anchor" href="#82--race-condition">#</a> 8.2 锁如何避免 race condition</h3>
<h4 id="heading-18"><a class="anchor" href="#heading-18">#</a> 什么是锁</h4>
<p>锁即是一个对象，它有两个方法：</p>
<ol>
<li>acquire。acquire 接受一个指向 lock 的指针，表示获得一个锁。同一时间只能有一个进程获得锁。</li>
<li>release。release 同样接受一个指向 lock 的指针，表示释放一个锁。在锁被释放之前，其他尝试获得锁的进程阻塞。</li>
</ol>
<p>在锁获得之后、被释放之前，这之间的代码区域被称为 Criticle section，它通常会原子性地更新数据。</p>
<h3 id="83-"><a class="anchor" href="#83-">#</a> 8.3 什么时候使用锁</h3>
<p>当两个进程共享同一数据结构，且其中一个进程想要更改共享的数据结构时需要加锁。</p>
<h3 id="84-"><a class="anchor" href="#84-">#</a> 8.4 锁的特性和死锁</h3>
<h4 id="heading-19"><a class="anchor" href="#heading-19">#</a> 锁的特性</h4>
<ol>
<li>避免丢失数据更新</li>
<li>打包多个操作，使其具有原子性</li>
<li>维护共享数据的不变性</li>
</ol>
<h4 id="heading-20"><a class="anchor" href="#heading-20">#</a> 死锁</h4>
<p>死锁即由于锁的原因导致程序永远阻塞。</p>
<p>最简单的死锁是重复获得一个未被释放的锁。对于多个 CPU 的场合，由于锁的获得和释放的顺序不正确，可能导致 deadly embrace，即两个或更多进程间因互相等待锁的释放而造成的死锁。</p>
<p>因此我们需要以合理的顺序获得和释放锁，这要求对锁进行排序，但该操作又会破坏程序的模块化。</p>
<h3 id="85-xv6-"><a class="anchor" href="#85-xv6-">#</a> 8.5 xv6 自旋锁的实现</h3>
<h4 id="heading-21"><a class="anchor" href="#heading-21">#</a> 自旋锁的结构</h4>
<p>xv6中自旋锁的定义如下：</p>
<p><img src="https://906337931-files.gitbook.io/~/files/v0/b/gitbook-legacy-files/o/assets%2F-MHZoT2b_bcLghjAOPsJ%2F-MPS4AMuEHdeXFZVa2tv%2F-MPTKBMvidl5JDe89V15%2Fimage.png?alt=media&amp;token=b9427226-3928-4e4d-a1cc-04c13641fe75" alt=""></p>
<p>locked 表明是否上锁，name 是锁的名称，cpu 表示当前锁被哪个 cpu 持有。</p>
<h4 id="heading-22"><a class="anchor" href="#heading-22">#</a> 获取锁</h4>
<p><img src="https://906337931-files.gitbook.io/~/files/v0/b/gitbook-legacy-files/o/assets%2F-MHZoT2b_bcLghjAOPsJ%2F-MPS4AMuEHdeXFZVa2tv%2F-MPTLYWRF8Z7xnWXnrs2%2Fimage.png?alt=media&amp;token=03319722-1193-4ab4-bb36-23dbc3c11fae" alt=""></p>
<p>获取锁的最大挑战是保证设置 locked 字段的操作的原子性，这时由 amoswap 指令实现的。它接受一个地址和两个寄存器r1，r2。它会先锁定地址，将地址中的数据保存到一个临时变量，然后将r1中的数据写入地址，再将临时变量中的数据写入r2，最后解锁地址。</p>
<p>在流程中最重要的是 <code>lock_test_and_set</code> 循环。该函数实现了 atomic swap 操作：若锁未被持有，则 locked 字段为 0，这时将其设为 1，然后返回原数值 0，退出循环；若锁被持有，则 locked 字段为 1，这时再次对其写入 1，返回原数值 1，继续循环。</p>
<p><img src="https://906337931-files.gitbook.io/~/files/v0/b/gitbook-legacy-files/o/assets%2F-MHZoT2b_bcLghjAOPsJ%2F-MPS4AMuEHdeXFZVa2tv%2F-MPTNUkQSugrjhscfd94%2Fimage.png?alt=media&amp;token=e67cecca-85fa-4c2e-9040-441dd85fdfd0" alt=""></p>
<h4 id="heading-23"><a class="anchor" href="#heading-23">#</a> 释放锁</h4>
<p><img src="https://906337931-files.gitbook.io/~/files/v0/b/gitbook-legacy-files/o/assets%2F-MHZoT2b_bcLghjAOPsJ%2F-MPTWI4LYcl0jB6hDkgX%2F-MPU8Xm8AmqsNVAEAaKb%2Fimage.png?alt=media&amp;token=ed3441cc-6193-45b1-9570-91d4d060aa0e" alt=""></p>
<p><code>lock_release</code> 同样使用原子方法将 locked 字段置为 0，从而实现锁的释放。</p>
<p><img src="https://906337931-files.gitbook.io/~/files/v0/b/gitbook-legacy-files/o/assets%2F-MHZoT2b_bcLghjAOPsJ%2F-MPS4AMuEHdeXFZVa2tv%2F-MPTQ6_2PmfELO2S40wq%2Fimage.png?alt=media&amp;token=d7b4b0e0-50cf-4fd8-80b9-00fbb94522a4" alt=""></p>
<h2 id="9-"><a class="anchor" href="#9-">#</a> 9 线程切换</h2>
<h3 id="91-"><a class="anchor" href="#91-">#</a> 9.1 线程概述</h3>
<h4 id="heading-24"><a class="anchor" href="#heading-24">#</a> 为何使用多线程</h4>
<ol>
<li>希望计算机具有分时性，在同一时间能够执行多个任务。</li>
<li>多线程有时能够合理组织程序，降低程序复杂度。</li>
<li>多线程可通过并行计算提高计算机性能。</li>
</ol>
<h4 id="heading-25"><a class="anchor" href="#heading-25">#</a> 线程的定义</h4>
<p>对同时多任务编程的抽象，可被认为是串行执行代码的单元。线程具有状态，因此我们可以随时保存其状态并暂停或恢复它。线程的状态包括：</p>
<ol>
<li>程序计数器（PC），表示当前线程执行的位置</li>
<li>保存变量的寄存器</li>
<li>程序的栈，记录了函数调用情况，同时反映当前线程的执行点</li>
</ol>
<h4 id="heading-26"><a class="anchor" href="#heading-26">#</a> 多线程并行</h4>
<p>多线程并行一般有两种策略：在每个 CPU 上运行一个线程，以及在一个 CPU 上运行多个线程。</p>
<p>在 xv6 中，内核线程共享内存，而用户线程独立运行；对于更复杂的 Linux 系统，一个用户进程也往往包含多个线程。</p>
<h3 id="92-"><a class="anchor" href="#92-">#</a> 9.2 线程调度</h3>
<h4 id="heading-27"><a class="anchor" href="#heading-27">#</a> 线程系统遇到的挑战</h4>
<ol>
<li>如何实现线程切换。线程切换的过程称为线程调度，每个CPU都实现了一个线程调度器</li>
<li>决定在线程切换时保留哪些信息以及如何保存。</li>
<li>如何处理运算密集型线程</li>
</ol>
<h4 id="heading-28"><a class="anchor" href="#heading-28">#</a> 如何处理运算密集型线程</h4>
<p>运算密集型线程无法自愿出让给其他线程，因此需要从长时间运行的运算密集型线程中撤回对 CPU 的控制以转交给其他线程使用。</p>
<p>处理方法是使用定时器中断，强制从用户空间进程获得 CPU 控制权。中断处理程序使得 CPU 出让给线程调度器，以便完成线程切换。</p>
<p>这里涉及两个流程：</p>
<ol>
<li>pre-emptive scheduling。即使用户代码未出让 CPU，定时器中断仍然强制取得 CPU 控制权，并出让给线程调度器。</li>
<li>voluntary scheduling。内核中用户进程对应内核线程代表用户进程出让 CPU。</li>
</ol>
<p>线程分为以下几类，分别对应以下几种状态：</p>
<ol>
<li>当前 CPU 上运行的线程，对应 RUNNING 状态</li>
<li>等待 CPU 运行的线程，对应 RUNABLE 状态（即能够被执行）</li>
<li>没有在等待 CPU 运行的线程，可能在等待 I/O 或其他事件，对应 SLEEPING 状态</li>
</ol>
<p>线程切换实际上就是将一个 RUNNING 线程转换成一个 RUNABLE 线程，在切换过程中，需要拷贝其 CPU 状态（程序计数器和寄存器）到内存。</p>
<h3 id="93-xv6-"><a class="anchor" href="#93-xv6-">#</a> 9.3 xv6 线程切换</h3>
<h4 id="heading-29"><a class="anchor" href="#heading-29">#</a> 线程切换流程</h4>
<p>对于一个触发中断的用户程序来说，其用户空间状态保存在 <code>trapframe</code> 中，其对应内核线程的内核寄存器保存在一个 context 对象中，以供恢复使用。</p>
<p>线程切换流程如下：</p>
<ol>
<li>当从一个用户进程切换到另一个用户进程，需要从第一个用户进程进入到内核，保存进程状态并运行它的内核线程。</li>
<li>从第一个用户进程的内核线程切换到第二个用户进程的内核线程。</li>
<li>第二个用户进程的内核线程暂停自己，并恢复第二个用户进程的用户寄存器</li>
<li>第二个用户进程继续执行。</li>
</ol>
<h4 id="heading-30"><a class="anchor" href="#heading-30">#</a> 实际线程切换流程</h4>
<p>在第二步中，一个内核线程并不直接切换到另一个内核线程，而是切换到这个 CPU 对应的调度器线程，并由调度器线程（同样是一个内核线程）切换到下一个内核线程。</p>
<h4 id="heading-31"><a class="anchor" href="#heading-31">#</a> 线程切换程序</h4>
<p><img src="https://906337931-files.gitbook.io/~/files/v0/b/gitbook-legacy-files/o/assets%2F-MHZoT2b_bcLghjAOPsJ%2F-MPlA8TdJmidn6m4MngD%2F-MPnrlXVjhqSv55SaNaq%2Fimage.png?alt=media&amp;token=11b1bceb-efc7-4bdb-8ef1-511e44f8b149" alt=""></p>
<p>proc记录了进程状态相关的字段，其中：</p>
<ol>
<li>trapframe 字段保存用户空间线程寄存器</li>
<li>context 字段保存内核线程寄存器</li>
<li>kstack 表示当前进程内核保存函数调用的位置</li>
<li>state 保存进程状态：RUNNING、RUNABLE 或 SLEEPING</li>
<li>lock 字段是锁</li>
</ol>
<p><img src="https://906337931-files.gitbook.io/~/files/v0/b/gitbook-legacy-files/o/assets%2F-MHZoT2b_bcLghjAOPsJ%2F-MPlA8TdJmidn6m4MngD%2F-MPntE1YFDaXfM--9WoX%2Fimage.png?alt=media&amp;token=d67e55ae-f178-406a-8764-e59d4aac0070" alt=""></p>
<p>在代码中创建了两个计算密集型线程，当定时器中断发生时，devintr 函数中使用 yield 让出 CPU 并允许线程切换。</p>
<p><img src="https://906337931-files.gitbook.io/~/files/v0/b/gitbook-legacy-files/o/assets%2F-MHZoT2b_bcLghjAOPsJ%2F-MPo3XwIXuht-vwuwogZ%2F-MPqDSuDUAjxhmKs3bRj%2Fimage.png?alt=media&amp;token=a35fcd6d-48db-4d1f-9990-b18150ecada7" alt=""></p>
<p>yield 函数获取进程的锁，以阻止其他 CPU 调度器线程由于状态被改变为 RUNNABLE 而运行该进程；改变进程状态为 RUNNABLE，接着调用 sched 函数：</p>
<p><img src="https://906337931-files.gitbook.io/~/files/v0/b/gitbook-legacy-files/o/assets%2F-MHZoT2b_bcLghjAOPsJ%2F-MPo3XwIXuht-vwuwogZ%2F-MPqG5J_0Kd38sS3FXWM%2Fimage.png?alt=media&amp;token=eab1e070-55e5-49d6-b66f-99c4b7f5c14a" alt=""></p>
<p>sched 先进行合理性检查，然后利用 switch （核心）函数将内核线程寄存器保存在 <code>p-&gt;context</code> 中，然后从 <code>c-&gt;context</code> 恢复当前 CPU 调度线程寄存器，从而执行 CPU 调度线程。</p>
<h2 id="10-"><a class="anchor" href="#10-">#</a> 10 睡眠和唤醒</h2>
<h3 id="101-"><a class="anchor" href="#101-">#</a> 10.1 线程切换过程中锁的限制</h3>
<ol>
<li>不允许进程在执行 switch 过程中持有其他锁</li>
<li>调用 switch 函数过程中，必须持有 p-&gt;lock</li>
</ol>
<h3 id="102-sleepwakeup"><a class="anchor" href="#102-sleepwakeup">#</a> 10.2 Sleep&amp;Wakeup</h3>
<h4 id="sleepwakeup-"><a class="anchor" href="#sleepwakeup-">#</a> Sleep&amp;Wakeup 有什么作用</h4>
<p>当我们需要等待一个 I/O 事件时，通常会出让 CPU，此时调用 Coordination（协调机制）。在 xv6 和大多数 Unix 操作系统中，Coordination 是通过 Sleep&amp;Wakeup 方式实现的。</p>
<h4 id="sleepwakeup--1"><a class="anchor" href="#sleepwakeup--1">#</a> Sleep&amp;Wakeup 的机制</h4>
<p>当一个进程需要等待某个时间，会调用 sleep 函数并等待特定条件；当条件满足，代码调用 wakeup 函数以唤醒进程。</p>
<p>sleep 和 wakeup 往往是成对出现的。它们之间通过 sleep channel 进行链接，以决定 wakeup 所唤醒的是哪个进程。</p>
<p>对于 sleep，它接受一个 sleep channel 参数，然后将进程的状态设为 SLEEPING，表示进程不运行。</p>
<p>对于 wakeup，它检查进程状态，如果进程状态是 SLEEPING 且对应的 channel 是 wakeup 接收到的参数，则将进程状态设置为 RUNNABLE。</p>
<h3 id="103-lost-wakeup"><a class="anchor" href="#103-lost-wakeup">#</a> 10.3 Lost Wakeup</h3>
<p>lost wakeup 是指内核发起唤醒信号但未能成功唤醒进程的情况。</p>
<p>其发生原因之一是：sleep 在释放锁之前，进程未进入 SLEEPING 状态，此时中断处理程序获取锁并调用了 wakeup，导致唤醒未能生效，从而使进程一直处于 SLEEPING 情况。</p>
<p>解决方法是：sleep 获取一个锁作为参数，当获取进程锁后才释放传入的锁；wakeup 同时获取两个锁。</p>
<h3 id="104-exit"><a class="anchor" href="#104-exit">#</a> 10.4 exit</h3>
<p>我们使用 exit 系统调用以释放一个进程。</p>
<p>在杀死线程过程中，该线程可能正在更新复杂内核数据，或是持有重要系统资源（互斥锁等），因此 exit 无法在进程运行时执行。</p>
<p>exit 的流程如下：</p>
<ol>
<li>关闭所有已经打开的文件</li>
<li>释放目录引用</li>
<li>如果有子进程，设置子进程的父进程为 PID 为 1 的进程（init 进程）</li>
<li>使用 wakeup 唤醒父进程</li>
<li>将当前进程的状态设置为 ZOMBIE，此时并未释放全部资源</li>
<li>父进程的 wait 返回，调用 freeproc 释放子进程的剩余资源，子进程的状态设置为 UNUSED</li>
</ol>
<h3 id="105-kill"><a class="anchor" href="#105-kill">#</a> 10.5 kill</h3>
<p>kill 系统调用的功能是：kill 接受一个 PID，然后使该进程停止运行。</p>
<p>kill 的流程如下：</p>
<ol>
<li>扫描进程表单，查找目标进程，将进程 proc 结构体中 killed 位设置为 1。若进程处于 SLEEPING 状态则设置为 RUNNABLE（被唤醒）。</li>
<li>进程运行到可安全停止位置时，检查 killed 标志位，若设置为 1，则自愿执行 exit</li>
</ol>
<p>因此 kill 系统调用十分温和，只有在进程下一次执行系统调用或触发中断时才会退出。</p>
<h2 id="11--1"><a class="anchor" href="#11--1">#</a> 11 文件系统</h2>
<h3 id="111-"><a class="anchor" href="#111-">#</a> 11.1 文件系统实现概论</h3>
<h4 id="heading-32"><a class="anchor" href="#heading-32">#</a> 文件系统的特性</h4>
<ol>
<li>提供了用户友好的文件名以及层级路径名</li>
<li>提供了信息的持久化存储</li>
</ol>
<h4 id="heading-33"><a class="anchor" href="#heading-33">#</a> 文件系统的机制</h4>
<ol>
<li>文件系统提供了对硬件的抽象</li>
<li>文件系统提供了很好的 crash safety，支持在计算机崩溃后维持文件系统的完好</li>
<li>合理的在磁盘上排布文件的方式</li>
<li>性能机制。通过 buffer cache 或 block cache，并行等方式加速文件系统的使用。</li>
</ol>
<h4 id="-api"><a class="anchor" href="#-api">#</a> 文件系统 API</h4>
<ol>
<li>open 系统调用创建或打开文件，返回文件描述符。它使用文件路径名确认文件。</li>
</ol>
<pre><code class="language-c">fd=open(&quot;x/y&quot;,O_RDONLY)
</code></pre>
<ol start="2">
<li>write 系统调用向文件中写数据</li>
</ol>
<pre><code class="language-c">write(fd,&quot;abc&quot;,3)
</code></pre>
<ol start="3">
<li>link 系统调用创建链接</li>
</ol>
<pre><code class="language-c">link(&quot;x/y&quot;,&quot;x/z&quot;)
</code></pre>
<h4 id="inode"><a class="anchor" href="#inode">#</a> inode和文件描述符</h4>
<p>inode 是文件系统中代表文件的对象，通过编号（int）进行区分，它实现了 read 和 write 方法，同时实现了引用计数以支持链接。</p>
<p>文件描述符（file descriptor）主要与用户进程交互，它维护了文件的 offset。</p>
<h4 id="heading-34"><a class="anchor" href="#heading-34">#</a> 文件系统结构</h4>
<p><img src="https://906337931-files.gitbook.io/~/files/v0/b/gitbook-legacy-files/o/assets%2F-MHZoT2b_bcLghjAOPsJ%2F-MRhBFGrbi6iZo-luZ0H%2F-MRhtSv2iQvU3nu1K7ZF%2Fimage.png?alt=media&amp;token=be934984-d1c5-4fbc-9618-21eb6b6f3373" alt=""></p>
<p>文件系统自底向上结构分别为：</p>
<ol>
<li>文件系统的最底层是磁盘，磁盘提供了持久化存储</li>
<li>buffer cache/block cache，通过将数据保存在内存中以避免频繁读写磁盘</li>
<li>logging 层</li>
<li>inode cache，负责同步</li>
<li>inode</li>
<li>文件名、文件描述符操作 API</li>
</ol>
<h3 id="112-"><a class="anchor" href="#112-">#</a> 11.2 文件系统存储设备</h3>
<h4 id="sector--block"><a class="anchor" href="#sector--block">#</a> sector 和 block</h4>
<ul>
<li>sector 是磁盘驱动可以读写的最小单元，通常是 512 字节</li>
<li>block 是操作系统/文件系统视角的数据，通常是 1024 字节</li>
</ul>
<p>文件系统运行在 CPU 上，将内部数据存储在内存，会读取 block 形式存储在 SSD 或 HDD 设备上的数据。其 api 包括 read/write。</p>
<h4 id="heading-35"><a class="anchor" href="#heading-35">#</a> 磁盘</h4>
<p>文件系统提供了对磁盘的抽象，在文件系统看来磁盘是一个 block 的数组。</p>
<p><img src="https://906337931-files.gitbook.io/~/files/v0/b/gitbook-legacy-files/o/assets%2F-MHZoT2b_bcLghjAOPsJ%2F-MRhzbAZwhuzp63wWdRE%2F-MRielGcbrHOzPCrxHcO%2Fimage.png?alt=media&amp;token=f685aafe-7c22-4965-9936-d811b090023d" alt=""></p>
<p>下面是一种常见的文件系统磁盘布局（同样是 xv6 的布局）：</p>
<ul>
<li>block0 要么闲置要么用作 boot sector，包含了启动操作系统的代码</li>
<li>block1 被称为 super block，描述了文件系统。其保存文件系统的大部分信息。</li>
<li>block2-block32 是 log 区。其大小可能视文件系统而不同。</li>
<li>block32-block45 存储 inode，一个 inode 是 64 字节。</li>
<li>block46 是 bitmap block，占据一个 block，记录数据 block 是否空闲</li>
<li>之后是数据 block，存储文件和目录（文件夹）内容</li>
</ul>
<p>其中，bitmap block，inode blocks，log blocks 被统称为 metadata block，存储文件系统元数据。</p>
<h3 id="143-inode"><a class="anchor" href="#143-inode">#</a> 14.3 inode</h3>
<p><img src="https://906337931-files.gitbook.io/~/files/v0/b/gitbook-legacy-files/o/assets%2F-MHZoT2b_bcLghjAOPsJ%2F-MRhzbAZwhuzp63wWdRE%2F-MRiq3PDZ1MKm5xRPATf%2Fimage.png?alt=media&amp;token=b690c6fe-e665-4ded-adc7-91be326015d0" alt=""></p>
<p>一个 inode 占据 64 字节，它包括以下字段：</p>
<ul>
<li>type，表明 inode 是文件或目录</li>
<li>nlink，link 计数器，跟踪多少文件名指向当前 inode</li>
<li>size，表明文件数据有多少字节</li>
<li>direct block number，在 xv6 中有 11 个 direct block number 字段，直接指向文件对应的前 11 个块的编号</li>
<li>indirect block number，指向一个 block，当文件拥有的块超出 direct block number 的数量，则在 indirect block 中记录其他块的数值编号</li>
</ul>
<h4 id="directory"><a class="anchor" href="#directory">#</a> 目录（directory）</h4>
<p>目录提供了层次化的命名空间。目录包含了 directory entries，每一个 entry 长度为 16 个字节，都是下面这样的数据结构：</p>
<p><img src="https://906337931-files.gitbook.io/~/files/v0/b/gitbook-legacy-files/o/assets%2F-MHZoT2b_bcLghjAOPsJ%2F-MRiqHd8klcdJiYeRvr7%2F-MRjJHrfQCURA-qgeXJN%2Fimage.png?alt=media&amp;token=6c7a7330-c2ea-4c6b-93d4-7a64f2f7b489" alt=""></p>
<ul>
<li>entry 的前两个字节包含了目录中文件或子目录的 inode 编号</li>
<li>后 14 个字节包含了文件名或子目录名</li>
</ul>
<h4 id="heading-36"><a class="anchor" href="#heading-36">#</a> 文件查找流程</h4>
<p>对于路径名&quot;/y/x&quot;对应的文件：</p>
<ol>
<li>首先从 root inode 开始查找，文件系统中 root inode 的编号是确定的</li>
<li>扫描 root inode 下所有 block，找到 y，假设它的 inode 编号是 251</li>
<li>查找 inode 251，扫描其下所有 block，找到 x 并得到对应的 inode 编号</li>
</ol>
<h4 id="heading-37"><a class="anchor" href="#heading-37">#</a> 文件创建流程</h4>
<ol>
<li>在inode block中找到一个空闲的inode索引，分配给新创建的文件。</li>
<li>在inode数组中为新创建的文件分配一个inode结构体，并初始化文件的属性。</li>
<li>在数据块位图中找到一组空闲的数据块索引，分配给新创建的文件。</li>
<li>更新inode block和数据 block。</li>
<li>在父级目录的 inode 中加入新创建文件的目录项，包括文件名和对应的 inode 索引。</li>
<li>更新 root inode，修改 size 字段以包含新创建的文件</li>
</ol>
<p>简单来说，即是分配 inode 并更新新文件的 data block</p>
<h4 id="block-cache"><a class="anchor" href="#block-cache">#</a> block cache</h4>
<p>为了减少磁盘开销，以及加速文件读写，通常采用缓存机制。当应用程序读取或写入文件，首先检查块缓存，如果在缓存中则无需访问磁盘。</p>
<p>块缓存中的数据有两种策略：</p>
<ol>
<li>写回策略：数据块的修改不会被立刻写回磁盘，而是在满足一定条件（如I/O延迟，缓存阈值，磁盘空闲）时写回并覆盖磁盘原有内容，可以减少磁盘读写</li>
<li>强制写入策略：数据块修改立刻写回磁盘，可保证数据一致性，但会增加磁盘开销并影响性能</li>
</ol>
<h2 id="12--1"><a class="anchor" href="#12--1">#</a> 12 崩溃恢复</h2>
<h3 id="121-"><a class="anchor" href="#121-">#</a> 12.1 文件系统崩溃</h3>
<p>文件系统安全要求文件系统在遭遇崩溃（文件系统操作过程中的电力故障和内核 panic）恢复后仍然能够正常使用。</p>
<p>文件系统安全通常使用 logging 解决。</p>
<h3 id="122-logging"><a class="anchor" href="#122-logging">#</a> 12.2 logging</h3>
<h4 id="heading-38"><a class="anchor" href="#heading-38">#</a> 特点</h4>
<ul>
<li>logging 保证了文件系统的系统调用是原子性的，从而避免系统调用写了一半的情况</li>
<li>支持快速恢复，相比读取全文件系统 block 进行恢复成本要小得多</li>
<li>性能高：logging 本身十分高效</li>
</ul>
<h4 id="heading-39"><a class="anchor" href="#heading-39">#</a> 实现方式</h4>
<p>logging 将磁盘分为 log 和文件系统两部分。</p>
<ol>
<li>log write: 任何对文件系统的操作都将先写入 log。</li>
<li>commit op: 当一系列对文件系统的操作结束，使用 commit 提交操作，同时在 log 中记录操作的个数</li>
<li>install log: 执行操作，将 log 分区的 block 移至文件系统分区即可</li>
<li>clean log: 清除 log，将 log 中操作个数设置为 0</li>
</ol>
<p>对于各种崩溃的情况：</p>
<ol>
<li>如果崩溃发生在 1-2，什么都不做</li>
<li>如果崩溃发生在 2-4，可以执行第 3 步而不必担心破坏文件系统，因为重复写入是允许的</li>
</ol>
<h4 id="log-"><a class="anchor" href="#log-">#</a> log 结构</h4>
<p><img src="https://906337931-files.gitbook.io/~/files/v0/b/gitbook-legacy-files/o/assets%2F-MHZoT2b_bcLghjAOPsJ%2F-MS_F6nYy0utF738c_Y7%2F-MS_Jd_2T4uf7GBC3ayB%2Fimage.png?alt=media&amp;token=376169b6-3c62-40c2-989d-63925944752c" alt=""></p>
<p>log 结构如图所示：</p>
<ol>
<li>第一个 block 称为 header block，其中：n 表示有效的 log block 数量，剩下的字段表示有效的 log block 对应的编号</li>
<li>接下来的 block 是 log 的数据块。</li>
</ol>
<h4 id="heading-40"><a class="anchor" href="#heading-40">#</a> 崩溃恢复流程</h4>
<ol>
<li>文件系统崩溃后重启，调用 initlog 函数（实际调用 recover_from_log 函数）</li>
<li>先调用 read_head 函数从磁盘中读取 header</li>
<li>之后调用 install_trans 函数读取 log header 中的 n，然后根据 n 将所有 log block 拷贝到文件系统 block（步骤 3），然后清除 log（步骤 4）</li>
</ol>
<p>说人话，先读取 header 块，然后分别执行步骤 3 和步骤 4</p>
<h3 id="123-logging-"><a class="anchor" href="#123-logging-">#</a> 12.3 logging 面临的挑战</h3>
<h4 id="cache-eviction"><a class="anchor" href="#cache-eviction">#</a> cache eviction（缓存淘汰）</h4>
<p>当缓存满了，我们需要选择块进行淘汰（写入磁盘）；但并非所有块都是可以写回的（因为要满足操作的原子性）</p>
<p>我们使用 pin/unpin，利用引用计数的方式淘汰未被引用的块。</p>
<h4 id="log"><a class="anchor" href="#log">#</a> 文件系统操作必须适配log大小</h4>
<p>假设 log block 的最大数量为 30，这意味着文件系统尝试写入的最大 block 数为 30。尝试写入超过这个数值的操作是不允许的（因为会被写入文件系统区域）</p>
<p>因此，一个大的写操作通常被分成多个小的写操作。</p>
<p>另外，buffer cache 的尺寸必须要大于 log（因为需要完整缓存 log 数据）</p>
<h4 id="heading-41"><a class="anchor" href="#heading-41">#</a> 并发文件系统调用</h4>
<p>在两个并发的写操作过程中，如果它们总的大小超过 log，有可能发生没有一个操作可以提交的情况。</p>
<p>此时，我们需要保证写的总 log 数小于 log 区域大小。我们可以通过 group commit 实现，即将同时提交多个操作（多个操作作为一个原子行为）。</p>
<h2 id="13--ext3-"><a class="anchor" href="#13--ext3-">#</a> 13 文件系统性能和快速崩溃恢复（以 ext3 为例）</h2>
<h3 id="131--logging"><a class="anchor" href="#131--logging">#</a> 13.1 为什么学习 logging</h3>
<ol>
<li>logging 可以用在任何已知的存储系统故障恢复流程中</li>
<li>log 在分布式系统中也有大量应用</li>
<li>log 本身有很多有趣机制</li>
</ol>
<h3 id="132-logging-"><a class="anchor" href="#132-logging-">#</a> 13.2 logging 系统规则</h3>
<ol>
<li>write ahead rule：需要在 log 中定义好所有原子性更新然后才能应用，这是 logging 实现故障恢复的基础</li>
<li>freeing rule：在 log 中所有写操作已经被更新到文件系统之前不能释放 log</li>
</ol>
<h3 id="133-xv6-logging-"><a class="anchor" href="#133-xv6-logging-">#</a> 13.3 xv6 logging 方案的缺陷</h3>
<p>xv6 logging 方案的最大缺陷在于性能。在每次 commit 之后，需要执行多个写磁盘操作，这些操作是同步的，又因为磁盘读写相对较慢，因此耗时很长。</p>
<p>另外，每个 block 需要被写两次（一次 log，一次文件系统）。</p>
<h3 id="134-ext3-"><a class="anchor" href="#134-ext3-">#</a> 13.4 ext3 数据结构</h3>
<h4 id="heading-42"><a class="anchor" href="#heading-42">#</a> 内存中</h4>
<ul>
<li>block cache，用以缓存数据</li>
<li>transaction（可以粗略翻译成事务） 信息，包括序列号，修改的 block 编号（cache 中的），handle（读写 cache 的系统调用）</li>
</ul>
<h4 id="heading-43"><a class="anchor" href="#heading-43">#</a> 磁盘中</h4>
<ul>
<li>文件系统树，包括 inode、文件、目录</li>
<li>bitmap block，标记 data block 是否空闲</li>
<li>log 区域</li>
</ul>
<h3 id="135-ext3--log-"><a class="anchor" href="#135-ext3--log-">#</a> 13.5 ext3 对 log 的改进</h3>
<p><img src="https://906337931-files.gitbook.io/~/files/v0/b/gitbook-legacy-files/o/assets%2F-MHZoT2b_bcLghjAOPsJ%2F-MT66ObFz9yro09pElsP%2F-MT8GvWqF04nL5dPmHhj%2Fimage.png?alt=media&amp;token=a044312e-b866-4d72-9aec-87c08e2c87b0" alt=""></p>
<p>ext3 的 log 包含以下部分：</p>
<ol>
<li>第一个 block 被称为 super block，其中包含了第一个有效 transaction 的起始位置（log 分区中的 block 编号）和序列号</li>
<li>之后的块均用来存放 transaction，对一个 transaction，它的数据结构如下：
<ul>
<li>首先是一个 descriptor block，它与 header block 类似，包含 log 数据对应的实际 block 编号</li>
<li>然后是对每一个 block 的更新数据</li>
<li>最后是一个 commit block</li>
</ul>
</li>
</ol>
<h3 id="136-ext3-"><a class="anchor" href="#136-ext3-">#</a> 13.6 ext3 性能提升措施</h3>
<h4 id="heading-44"><a class="anchor" href="#heading-44">#</a> 异步的系统调用</h4>
<p>异步的系统调用即是应用程序调用文件系统的系统调用，但是仅修改完毕缓存中的 block 即返回，不去执行耗时更长的写磁盘操作。</p>
<p>与此同时，文件系统在后台并行地进行写磁盘操作。通过这种方式，实现了 I/O 并发。</p>
<p>其优点在于，异步的系统调用加速了应用程序的运行，同时使得大批量的执行成为可能</p>
<p>其缺点在于，系统调用的返回结果不表示写操作的完成（也就是说，即使应用程序中写操作返回，我们也不能想当然地以为数据已经保存到磁盘上）。因此，在 crash 之后，我们要么拿到新文件（写操作完成），要么拿到旧文件（写操作未完成）。问题就在于，我们不知道拿到的是新文件还是旧文件。</p>
<p>为了保证异步 I/O 能够拿到可预期的结果，我们使用了 fsync 系统调用。它接受一个文件描述符，保证与该文件相关的写操作全部完成之后返回。但 fsync 会牺牲异步 I/O 带来的性能，因此通常只在必要的地方使用。另外，fsync 有时也被称为 flush。</p>
<h4 id="heading-45"><a class="anchor" href="#heading-45">#</a> 批量执行</h4>
<p>批量执行即是将多个操作打包成一个操作以统一执行。具体来说，ext3 同一时间只会有一个打开的 transaction（创建周期一般是 5s），在这 5s 之中，所有的操作均会打包在这个 transaction 之中；待结束之后统一提交执行。</p>
<blockquote>
<p>注意，ext3 在内存中执行的数据结构与 log 中不同：在内存中，有一个 transaction 打包批量执行系统调用，然后一次性将变更内容提交到 log 中持久化；此时 log 中可能存在多个已经 commit 的 transaction，当它们执行完毕（将数据写入 data block）时清空当前 transaction</p>
</blockquote>
<p>它的好处在于：</p>
<ol>
<li>避免查找和写元信息（descriptor block 和 commit block）的固有性能损耗</li>
<li>对于多次修改同一 block 的情况，可避免多次不必要的磁盘读写，现在可以在内存中完成</li>
<li>向磁盘中连续的 block 写入比写入零散的 block 效率更高。</li>
</ol>
<h4 id="heading-46"><a class="anchor" href="#heading-46">#</a> 并发</h4>
<p>ext3的并发体现在：</p>
<ol>
<li>允许多个系统调用同时修改当前的 transaction</li>
<li>允许不同状态的 transaction 存在：内存中一个打开的 transaction 接受系统调用，log 中多个 transaction 可以写数据，以及正在被释放的 transaction</li>
</ol>
<h3 id="137-ext3-"><a class="anchor" href="#137-ext3-">#</a> 13.7 ext3 系统调用</h3>
<pre><code class="language-c">// 标志transaction的开始，获取一个handle
h = start()
// 获取要修改的block对应的缓存
get(h, block_number)
// 修改缓存的内容，略
...
// 标志transaction的结束
stop(h)
</code></pre>
<p>我们需要 <code>start</code> 和 <code>stop</code> 来标志一个 transaction 的起始，以便我们能够获得当前事务的个数。</p>
<h4 id="commit"><a class="anchor" href="#commit">#</a> commit</h4>
<p>当全部 transaction 结束，我们可以提交操作：</p>
<ol>
<li>阻止新的系统调用（因为同一时间只有一个接收系统调用的transaction），系统调用等待</li>
<li>等待这个 transaction 中的系统调用完成，即数据已经更新到 cache 中。</li>
<li>开启一个新的 transaction，以接收系统调用</li>
<li>更新 descriptor block，其中包含所有被修改了的 block 编号</li>
<li>将 cache 中的 block 写入 log</li>
<li>等待前两步写 log 操作结束，写入 commit block</li>
<li>等待写 commit block 结束，则表示当前 transaction 抵达 commit point（在之后遇到 panic 则退回此处继续执行）</li>
<li>将 transaction 中 block 写入文件系统实际位置</li>
<li>释放 transaction，重用空间</li>
</ol>
<h4 id="heading-47"><a class="anchor" href="#heading-47">#</a> 恢复</h4>
<p>crash 并重启，意味着我们丢失了内存中的所有数据，而磁盘中的数据被保留。</p>
<p>crash 可能打断任何正在进行中的 transaction，包括正在 commit 的以及正在向文件系统写 block 的。</p>
<ol>
<li>crash 并重启，读取 super block，得到 log 起始位置；然后线性扫描直到找到 log 结束位置。</li>
<li>当某个 commit block 后的一个 block 不是 descriptor block，或 descriptor block 无法找到 commit block，则停止扫描，将这个 commit block 认为是最后一个合法位置。</li>
<li>然后根据 log 将数据写入文件系统</li>
</ol>
<h4 id="-transaction-"><a class="anchor" href="#-transaction-">#</a> 为何不能同时有两个 transaction 接收系统调用</h4>
<p>第二个 transaction 可能会读写第一个 transaction 的 block，从而被当作第一个 transaction 执行，从而使第一个 transaction 失去原子性。</p>
</article>
  </div>
</body>

</html>