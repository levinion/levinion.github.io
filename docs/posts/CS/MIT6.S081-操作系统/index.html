<!DOCTYPE html>
<html data-theme="dark">

<head>
  
<meta charset="UTF-8" />
<meta http-equiv="X-UA-Compatible" content="IE=edge" />
<meta name="viewport" content="width=device-width, initial-scale=1.0" />
<link rel="stylesheet" href="/assets/css/pico.css" />
<link rel="stylesheet" href="/assets/css/custom.css" />
<link rel="stylesheet"
      href="//cdnjs.cloudflare.com/ajax/libs/highlight.js/11.7.0/styles/atom-one-dark.min.css">
<script src="//cdnjs.cloudflare.com/ajax/libs/highlight.js/11.7.0/highlight.min.js"></script>
<script>
    hljs.initHighlightingOnLoad();
</script> 


  <style>
    article {
      background: rgb(28, 29, 33);
      max-width: 70%;
      text-align: left;
      margin: 0 auto;
      border-radius: 30px;
    }

    @media (max-width: 768px) {
      article {
        max-width: 90%;
      }

      h1 {
        font-size: large;
      }

      .date {
        font-size: medium;
      }

      p,
      li {
        font-size: 15px;
      }
    }

    p,
    li {
      font-size: 16.5px;
      line-height: 32px;
    }

    h1 {
      text-align: center;
      margin-bottom: 10px;
    }

    .meta p {
      text-align: center;
    }

    .date {
      text-align: center;
    }

    .toc {
      position: fixed;
      float: left;
      max-width: 50px;
      max-height: 50px;
      margin-top: 200px;
      text-align: center;
    }

    h2 {
      font-size: x-large;
      color: peru;
    }

    h3 {
      font-size: large;
      color: rgb(205, 158, 112);
    }

    h4 {
      font-size: medium;
      color: pink;
    }

    strong {
      color: rgb(182, 230, 240);
    }
  </style>
  <title>MIT6.S081-操作系统</title>
</head>

<body onselectstart="return false">
  
<nav>
  <a href="/" class="logo">Maruka's Blog</a>
  <div class="breadcrumb">
    <ul>
      <li>
        <a href="/posts">文章</a>
      </li>
      <li>
        <a href="/category">分类</a>
      </li>
      <li>
        <a href="/about">关于</a>
      </li>
    </ul>
  </div>
</nav>

  <div>
    <div class="meta">
      <h1>MIT6.S081-操作系统</h1>
      <p>2023-06-24 17:36:35</p>
    </div>
    <article><h2 id="1-"><a class="anchor" href="#1-">#</a> 1 引言</h2>
<h3 id="11-"><a class="anchor" href="#11-">#</a> 1.1 课程内容简介</h3>
<h4 id="heading"><a class="anchor" href="#heading">#</a> 课程目标</h4>
<ol>
<li>理解操作系统的设计和实现。设计指具体结构，实现指具体代码。</li>
<li>通过现有的示例操作系统（XV6），对其进行扩展，并通过接口开发软件，以作为实践环节。</li>
</ol>
<h4 id="heading-1"><a class="anchor" href="#heading-1">#</a> 操作系统目标</h4>
<ol>
<li>硬件抽象。以便从高层次操作硬件，以获得更好的通用性和可移植性。</li>
<li>并发性。能够同时使用多个应用程序。</li>
<li>隔离性。能够隔离应用程序，防止 bug 的传播。</li>
<li>共享性。能够共享内存，从而进行数据交互。</li>
<li>安全性。拥有权限机制从而禁止或允许用户的操作。</li>
<li>高性能。操作系统应当能够发挥出硬件的全部性能。</li>
<li>生态。一个好的操作系统应当能够支持大量不同类型的应用程序。</li>
</ol>
<h3 id="12-"><a class="anchor" href="#12-">#</a> 1.2 操作系统结构</h3>
<p>计算机的最底层是其所拥有的<strong>硬件资源</strong>，包括 CPU、内存、磁盘、网卡等。</p>
<p>最上层是<strong>用户空间</strong>，用户空间中运行着大量的应用程序。</p>
<p><strong>Kernel</strong>（内核）运行在硬件资源和用户空间之间。它是一个特殊的应用程序，负责维护用户空间进程（支持上层）以及管理硬件资源（调用下层）。</p>
<p>内核提供多种服务，包括文件系统和进程管理系统、进程间通信服务、网络和硬件驱动等。</p>
<p>应用程序通过系统调用（System Call）访问内核，其形式类似函数调用，典型的系统调用有 open、write、fork 等。</p>
<h3 id="13-"><a class="anchor" href="#13-">#</a> 1.3 挑战与乐趣并存</h3>
<h4 id="heading-2"><a class="anchor" href="#heading-2">#</a> 挑战</h4>
<ol>
<li>内核的<strong>编程环境恶劣</strong>，它并没有一个方便的软件基础，需要与底层的硬件资源交互。</li>
<li>操作系统的<strong>高效性和易用性之间的矛盾</strong>。高效性意味着操作层级应较低，而易用性则需要提供高层次的抽象接口。而对操作系统开发人员来说，我们又需要提供尽可能简单、却又功能性很强的接口。</li>
<li>应用程序的<strong>灵活性和安全性之间的矛盾</strong>。内核对应用程序的限制应尽可能小，从而保证其灵活性；但同时又要限制应用程序，以避免其对硬件的直接访问，从而破坏隔离性和安全性。</li>
<li>操作系统大量服务之间的交互是困难且复杂的。</li>
<li>操作系统需要紧跟硬件的发展。</li>
</ol>
<h4 id="heading-3"><a class="anchor" href="#heading-3">#</a> 乐趣</h4>
<ol>
<li>我们需要思考操作系统服务之间的交互方式，这应当是有趣的。</li>
<li>重新思考设计操作系统使其匹配最新硬件的过程是有趣的。</li>
<li>对计算机运行原理感兴趣，喜欢构建能够被其他应用程序使用的基础架构，或是为了定位操作系统级别的程序 BUG，都需要操作系统的知识。</li>
</ol>
<h3 id="14-readwriteexit-"><a class="anchor" href="#14-readwriteexit-">#</a> 1.4 read，write，exit 系统调用</h3>
<pre><code class="language-c">//copy.c :copy input to output.

#include &quot;kernel/types.h&quot;
#include &quot;user/user.h&quot;

int main(){
  char buf[64];
  while(1){
    int n=read(0，buf，sizeof(buf));
    if(n&lt;=0) break;
    write(1，buf，n);
  }
  exit(0);
}
</code></pre>
<h4 id="read"><a class="anchor" href="#read">#</a> read</h4>
<pre><code class="language-c">int n=read(0，buf，sizeof(buf))
</code></pre>
<p>read 系统调用接受三个参数：</p>
<ol>
<li>第一个参数是<strong>文件描述符</strong>，指向一个之前打开的文件。特别地，文件描述符 0 连接到 console 的输入，文件描述符 1 连接到 console 的输出。</li>
<li>第二个参数是<strong>指向某段内存的指针</strong>，程序可通过该指针读取相应地址内存中的数据。</li>
<li>第三个参数是<strong>代码读取的最大长度</strong>，在这里是 64 个字符。</li>
</ol>
<p>一般情况下，read 的返回值是读取到的字节数。当遇到文件尾，read 返回 0；当发生错误，read 返回-1。</p>
<h4 id="write"><a class="anchor" href="#write">#</a> write</h4>
<pre><code class="language-c">write(1，buf，n);
</code></pre>
<p>write 系统调用同样接受三个参数，其与 read 相同。</p>
<h4 id="exit"><a class="anchor" href="#exit">#</a> exit</h4>
<p>exit 接受一个参数，当为 0 时代表正常退出，否则表示发生错误。</p>
<h3 id="15-open-"><a class="anchor" href="#15-open-">#</a> 1.5 open 系统调用</h3>
<pre><code class="language-c">int fd = open(&quot;output.txt&quot;， O_WRONLY | O_CREATE);
</code></pre>
<p>open 系统调用接受 2 个参数。第一个参数表示打开的文件名，第二个参数是标志位，表示在内核中的实现。</p>
<p>open 返回一个新分配的文件描述符，可被用来执行其他系统调用。</p>
<p>文件描述符对应内核维护的一个表单数据，包括该文件所包含的所有数据。每个进程都拥有独立的文件描述符空间。</p>
<h3 id="16-fork-"><a class="anchor" href="#16-fork-">#</a> 1.6 fork 系统调用</h3>
<pre><code class="language-c">int pid = fork();

if (pid == 0){
  printf(&quot;child\n&quot;);
} else {
  printf(&quot;parent\n&quot;);
}
</code></pre>
<p>fork 的作用是拷贝当前进程的内存，并创建一个新进程。两个进程独立运行。在新进程中，pid 返回 0；而在原始进程中，pid 返回新进程的 pid，它是一个大于 0 的整数。</p>
<h3 id="17-execwait-"><a class="anchor" href="#17-execwait-">#</a> 1.7 exec，wait 系统调用</h3>
<h4 id="exec"><a class="anchor" href="#exec">#</a> exec</h4>
<pre><code class="language-c">char *argv[] = {&quot;echo&quot;， &quot;this&quot;， &quot;is&quot;， &quot;echo&quot;， 0 };
exec(&quot;echo&quot;， argv);
</code></pre>
<p>exec 从文件中读取并加载指令，替代当前进程指令。第一个参数接受文件路径名，第二个参数接受传入的命令行参数。</p>
<blockquote>
<p>Linux 中没有 exec，但有 exec 族函数。在此处比较接近的是 execv，位于 <code>unistd.h</code> 中</p>
</blockquote>
<p>exec 执行会替换当前进程，因此正常情况下无返回值，当前进程直接结束。因此我们通常将 exec 和 fork 组合使用。</p>
<p><img src="https://906337931-files.gitbook.io/~/files/v0/b/gitbook-legacy-files/o/assets%2F-MHZoT2b_bcLghjAOPsJ%2F-MIPPNbcxvfU0rZb3JHn%2F-MIUKdbclTLPYY8wEZKW%2Fimage.png?alt=media&amp;token=6d077551-35b1-4d2a-a1d7-d3399beef508" alt=""></p>
<h4 id="wait"><a class="anchor" href="#wait">#</a> wait</h4>
<pre><code class="language-c">wait(&amp;status);
</code></pre>
<p>wait 接受一个 int 地址参数，内核会等待子进程完成，并将子进程的返回值写入。如果子进程成功，则 status 为 0，否则为 1。</p>
<p>exec-fork 风格系统调用代价是高昂的，它为了开启一个子进程往往需要复制整个内存。</p>
<h3 id="18-io-"><a class="anchor" href="#18-io-">#</a> 1.8 I/O 重定向</h3>
<p><img src="https://906337931-files.gitbook.io/~/files/v0/b/gitbook-legacy-files/o/assets%2F-MHZoT2b_bcLghjAOPsJ%2F-MIPPNbcxvfU0rZb3JHn%2F-MIdhkxV4q6JhvAWWhEA%2Fimage.png?alt=media&amp;token=459186e7-79db-4fc2-84db-f3512de7fbd7" alt=""></p>
<p>I/O 重定向广泛用于 Unix 管道工具。它通过 <code>&gt;</code>、<code>&lt;</code> 等管道符改变默认的输出/输入文件符，从而实现 I/O 重定向。</p>
<h2 id="lab1"><a class="anchor" href="#lab1">#</a> Lab1</h2>
<ol>
<li>获取源代码并切换到util分支</li>
</ol>
<pre><code class="language-sh">git clone git://g.csail.mit.edu/xv6-labs-2021
cd xv6-labs-2021
git checkout util
</code></pre>
<ol start="2">
<li>尝试编译运行 xv6</li>
</ol>
<pre><code class="language-sh">make qemu
</code></pre>
<p>遇到报错如下：</p>
<pre><code class="language-sh">user/sh.c: In function 'runcmd':
user/sh.c:58:1: error: infinite recursion detected [-Werror=infinite-recursion]
   58 | runcmd(struct cmd *cmd)
      | ^~~~~~
user/sh.c:89:5: note: recursive call
   89 |     runcmd(rcmd-&gt;cmd);
      |     ^~~~~~~~~~~~~~~~~
</code></pre>
<p>修改 user/sh. c 文件，添加 noreturn 编译器属性以避免警告：</p>
<pre><code class="language-c">// Execute cmd.  Never returns.
__attribute__((noreturn))
void
runcmd(struct cmd *cmd)
</code></pre>
<p>编译成功</p>
<pre><code class="language-sh">xv6 kernel is booting

hart 1 starting
hart 2 starting
init: starting sh
$ 
</code></pre>
<ol start="3">
<li>sleep 程序</li>
</ol>
<p>在 user/user. h 中创建如下别名以解决报错，或选择在 <code>user/sleep.c</code> 中引入 <code>../kernel/types.h</code> 头文件：</p>
<pre><code class="language-c">#define uint unsigned int
//or
#include &quot;../kernel/types.h&quot;
</code></pre>
<p>编写 user/sleep. c：</p>
<pre><code class="language-c">#include &quot;user.h&quot;

int main(int argc， char **argv) {
  if (argc &lt;= 1) {
    printf(&quot;lack args\n&quot;);
    exit(1);
  }
  sleep(atoi(argv[1]));
  exit(0);
}
</code></pre>
<p>修改 makefile：</p>
<pre><code class="language-c">UPROGS=\
...
	$U/_sleep\
</code></pre>
<p>重新编译并运行：</p>
<pre><code class="language-sh">$ sleep
lack args
$ sleep 10
$ 
</code></pre>
<ol start="4">
<li>ping-pong 程序</li>
</ol>
<p>c 语言中管道图示如下：</p>
<p><img src="https://img-blog.csdnimg.cn/add7f392ea684a8ca9e717ac048df5db.png" alt=""></p>
<pre><code class="language-c">#include &quot;user.h&quot;

int main() {
  int p1[2]，p2[2];
  pipe(p1);
  pipe(p2);

  if (fork() == 0) {
    char buf[32];
    close(p2[0]);
    close(p1[1]);
    //read ping
    read(p1[0]， buf， 4);
    printf(&quot;%d: received %s\n&quot;， getpid()， buf);
    close(p1[0]);
    //write pong
    write(p2[1]， &quot;pong&quot;， 4);
    close(p2[1]);
    exit(0);
  } else {
    char buf[32];
    close(p1[0]);
    close(p2[1]);
    //write ping
    write(p1[1]， &quot;ping&quot;， 4);
    close(p1[1]);
    //read pong
    read(p2[0]， buf， 4);
    printf(&quot;%d: received %s\n&quot;， getpid()， buf);
    close(p2[0]);
    exit(0);
  }
}
</code></pre>
<p>注意修改 makefile（下同）。结果如下：</p>
<pre><code class="language-sh">$ pingpong
4: received ping
3: received pong
$ 
</code></pre>
<ol start="5">
<li>素数虽然难度标的是 hard，但其实并不太难，只是需要灵活应用 pipe：</li>
</ol>
<pre><code class="language-c">#include &quot;user.h&quot;

int work(int *p， int n) {
  // 读取上一个管道传入的数据
  int num;
  read(p[0]， &amp;num， 4);
  close(p[0]);
  // 递归退出条件：无法被整除，表明是素数，打印
  if (n == 1) {
    printf(&quot;prime %d\n&quot;， num);
    return 0;
  }
  // 若不能被整除，则新建一个管道并递归，否则返回
  if (num % n != 0) {
    int p1[2];
    pipe(p1);
    write(p1[1]， &amp;num， 4);
    close(p1[1]);
    work(p1， n - 1);
  }
  return 0;
}

int main() {
  // 倒序判断是否是素数
  for (int i = 1; i &lt; 36; i++) {
    int p[2];
    pipe(p);
    write(p[1]， &amp;i， 4);
    work(p， i-1);
    close(p[1]);
  }
  exit(0);
}
</code></pre>
<p>结果如下：</p>
<pre><code class="language-sh">$ primes
prime 2
prime 3
prime 5
prime 7
prime 11
prime 13
prime 17
prime 19
prime 23
prime 29
prime 31
$ 
</code></pre>
<ol start="6">
<li>find 程序</li>
</ol>
<pre><code class="language-c">#include &quot;../kernel/types.h&quot;
#include &quot;../kernel/fs.h&quot;
#include &quot;../kernel/stat.h&quot;
#include &quot;../user/user.h&quot;

// 获取文件的base name
char *getname(char *path) {
  char *p;
  // Find first character after last slash.
  for (p = path + strlen(path); p &gt;= path &amp;&amp; *p != '/'; p--)
    ;
  p++;
  return p;
}

void find(char *path， char *filename) {
  char buf[512];
  int fd = open(path， 0);
  struct stat st;
  struct dirent de;
  fstat(fd， &amp;st);
  switch (st.type) {
    // 如果path指示一个文件，则比较base name
  case T_FILE:
    if (strcmp(filename， getname(path)) == 0)
      printf(&quot;%s\n&quot;， path);
    break;
    // 若path指示一个目录，则递归搜索目录下的所有路径
  case T_DIR:
    // 处理路径，添加分隔符
    strcpy(buf， path);
    char *p = buf + strlen(buf);
    *p++ = '/';

    while (read(fd， &amp;de， sizeof(de)) == sizeof(de)) {
      if (de.inum == 0 || strcmp(de.name， &quot;.&quot;) == 0 ||
          strcmp(de.name， &quot;..&quot;) == 0)
        continue;

      // 处理路径，将读取到的文件/目录名追加到buf作为查找路径
      memmove(p， de.name， DIRSIZ);
      p[DIRSIZ] = 0;
      find(buf， filename);
    }
    break;
  }
  close(fd);
}

int main(int argc， char *argv[]) {
  if (argc &lt; 3) {
    printf(&quot;args is too short\n&quot;);
    exit(1);
  }
  find(argv[1]， argv[2]);
  exit(0);
}
</code></pre>
<p>结果如下：</p>
<pre><code class="language-sh">$ echo &gt; a
$ mkdir b
$ echo &gt; b/a
$ find . a
./a
./b/a
$ 
</code></pre>
<ol start="7">
<li>xargs 程序</li>
</ol>
<pre><code class="language-c">#include &quot;../kernel/param.h&quot;
#include &quot;user.h&quot;

int main(int argc， char *argv[]) {
  // 初始化参数列表
  char *params[MAXARG];

  // 判断xargs后的参数
  if (argc &gt; 1) {
    for (int i = 1; i &lt; argc; i++) {
      params[i - 1] = argv[i];
    }
  } else {
    printf(&quot;error\n&quot;);
    exit(1);
  }
  params[argc] = 0;

  // 从stdin读取参数，追加到参数列表最后
  // 注意这里的数组大小，若太大则可能溢出；
  char *buf[64];
  int i = 0;
  while (1) {
    int len = read(0， &amp;buf[i]， 16);
    if (len == 0 || buf[i] == (char *)'\n') {
      break;
    }
    i++;
  }
  buf[i] = 0;

  params[argc - 1] = (char *)buf;

  // 建立子进程，主进程等待
  if (fork() == 0) {
    exec(params[0]， params);
  } else {
    wait(0);
  }
  exit(0);
}
</code></pre>
<p>结果如下：</p>
<pre><code class="language-sh">$ echo hello too | xargs echo bye
bye hello to
</code></pre>
<h2 id="2-"><a class="anchor" href="#2-">#</a> 2 系统结构与系统调用</h2>
<h3 id="21-"><a class="anchor" href="#21-">#</a> 2.1 操作系统隔离性</h3>
<h4 id="heading-4"><a class="anchor" href="#heading-4">#</a> 为何需要隔离性</h4>
<ol>
<li>应用程序之间需要隔离性：在操作系统上运行的应用不应该不必要地影响其他正在运行的应用程序。</li>
<li>应用程序和操作系统之间需要隔离性：应用程序的崩溃不应该导致整个操作系统崩溃，要求操作系统有处理异常的能力。</li>
</ol>
<h4 id="heading-5"><a class="anchor" href="#heading-5">#</a> 操作系统隔离性的实现</h4>
<p>操作系统通过抽象阻止应用程序直接访问硬件资源，如进程是 CPU 的抽象、文件是磁盘的抽象。借助操作系统的抽象接口，能够实现多个应用程序复用计算机硬件资源，同时满足强隔离性的目的。</p>
<h3 id="22-"><a class="anchor" href="#22-">#</a> 2.2 操作系统防御性</h3>
<h4 id="heading-6"><a class="anchor" href="#heading-6">#</a> 为何需要防御性</h4>
<ol>
<li>操作系统需要应对恶意应用程序，防止恶意应用程序使操作系统崩溃。</li>
<li>操作系统应当保持对应用程序隔离，防止应用程序获取内核权限从而控制硬件资源。</li>
</ol>
<p>操作系统防御性是隔离性的表现之一。操作系统借助硬件支持，包括用户/内核态（user/kernel mode）和 page table（页表，或虚拟内存）实现强隔离。</p>
<h3 id="23-"><a class="anchor" href="#23-">#</a> 2.3 硬件对于强隔离的支持</h3>
<p>硬件对于强隔离的支持包括：user/kernel mode 和 page table。</p>
<h4 id="userkernel-mode"><a class="anchor" href="#userkernel-mode">#</a> user/kernel mode</h4>
<p>处理器具有两种操作状态：当运行在用户态时，只能够执行普通权限指令；当运行在内核态时，能够执行特殊权限指令。</p>
<p>普通权限指令包括寄存器的加减、跳转操作；特殊权限指令与硬件状态相关，如设置 page table 寄存器和控制时钟中断。</p>
<p>假如应用程序打算执行一条特殊权限指令，会由于用户态而拒绝执行。这时 CPU 会跳转到内核态，并且杀掉进程。</p>
<p>对于 RISC-V，处理器还具有第三种状态：机器态（machine mode）。机器态拥有最高的特权级别，能够执行任何指令，主要用于处理器初始化和异常/中断处理。</p>
<h4 id="heading-7"><a class="anchor" href="#heading-7">#</a> 虚拟内存</h4>
<p>page table 提供了虚拟内存地址和物理内存地址的对应关系。每一个独立进程都维护着一个独立的 page table，保证其物理内存地址不重叠，使其无法访问到其他应用程序的内存，从而保证了内存的隔离性。</p>
<h3 id="heading-8"><a class="anchor" href="#heading-8">#</a> 用户态/内核态切换</h3>
<p>用户态和内核态划定了用户空间和内核空间的界线：应用程序运行在用户空间，而内核程序运行在内核空间。</p>
<p>应用程序通过系统调用转移控制权给内核。在 RISC-V 中，通过 ECALL 指令转移控制权。</p>
<pre><code class="language-asm">ecall &lt;uint&gt;
</code></pre>
<p>ECALL 接受一个数字，可跳转到内核中特定的系统调用接入点。应用程序通过 syscall 函数发起系统调用，syscall 调用 ECALL，从而完成用户态/内核态切换。</p>
<h3 id="24-"><a class="anchor" href="#24-">#</a> 2.4 宏内核与微内核</h3>
<h4 id="tcb"><a class="anchor" href="#tcb">#</a> TCB</h4>
<p>TCB 即被信任的计算空间（Trusted Computing Base），代指安全的内核。一个安全的内核应当具有以下特征：</p>
<ol>
<li>内核应当具有尽可能少的漏洞。</li>
<li>内核应当认为所有应用程序都是恶意的。</li>
</ol>
<p>所有敏感的操作都应当运行在内核态，也就是 TCB 当中。</p>
<h4 id="heading-9"><a class="anchor" href="#heading-9">#</a> 宏内核</h4>
<p>所有操作系统服务均运行在内核态，这样的操作系统内核称为宏内核。绝大多数的 Unix 操作系统均是宏内核。</p>
<ul>
<li>Pro：宏内核组件具有良好的集成性，因此具有不错的性能</li>
<li>Cron：由于服务都运行在内核中，宏内核发生故障的可能性更大。</li>
</ul>
<h4 id="heading-10"><a class="anchor" href="#heading-10">#</a> 微内核</h4>
<p>微内核只在内核中提供了最基本的服务，以减少内核中的代码量。在微内核中，原本由内核提供的服务现在以一个用户程序的形式运行。</p>
<ul>
<li>Pro：微内核代码量少，发生 Bug 的可能性更低，因此更加安全。</li>
<li>Cron：需要在用户态和内核态之间反复跳转，也同时更难共享内存，从而带来性能损耗。</li>
</ul>
<h3 id="25-"><a class="anchor" href="#25-">#</a> 2.5 编译运行内核</h3>
<h4 id="xv6-"><a class="anchor" href="#xv6-">#</a> xv6 的代码结构</h4>
<ul>
<li>kernel：kernel 中包含了所有内核代码，这些代码编译成一个名叫 kernel 的二进制文件，该二进制文件运行在内核态中。</li>
<li>user：user 中包含了所有的用户程序。</li>
<li>mkfs：mkfs 创建一个空的文件镜像，通过挂载到磁盘上得到一个空的文件系统。</li>
</ul>
<h4 id="heading-11"><a class="anchor" href="#heading-11">#</a> 内核编译过程</h4>
<ol>
<li>编译：对每个. c 文件经编译器得到. s，这是 RISC-V 汇编代码文件</li>
<li>汇编：对. s 文件调用汇编器，形成. o，这是汇编代码的二进制形式</li>
<li>链接：使用系统加载器（Loader）链接成内核文件 kernel</li>
</ol>
<blockquote>
<p>这里所说的系统加载器也就是链接器（Linker）</p>
</blockquote>
<h3 id="26-xv6-"><a class="anchor" href="#26-xv6-">#</a> 2.6 xv6 启动过程</h3>
<blockquote>
<p>这部分内容比较零碎，由 claude 进行总结，我只是进行了一些整理和调整</p>
</blockquote>
<ol>
<li>XV6 的入口地址是 <code>0x80000000</code>， 这个地址是 QEMU 要求的硬性条件， XV6 的载入器 <code>kernel.ld</code> 会将内核加载到这个地址开始。</li>
<li>XV6 首先在 <code>entry.s</code> 中启动，此时还没有内存分页和进程隔离，处于 machine mode。XV6 会尽快切换到 supervisor mode。</li>
<li>其他初始化工作：
<ul>
<li>consoleinit: 初始化控制台，用于后续打印输出；</li>
<li>kinit: 初始化页表分配器；</li>
<li>kvminit: 初始化虚拟内存管理</li>
<li>kvminithart: 打开页表</li>
<li>processinit: 初始化进程表</li>
<li>trapinit/trapinithart: 初始化用户/内核模式切换</li>
<li>plicinit/plicinithart: 初始化中断控制器 PLIC</li>
<li>binit: 初始化缓冲区缓存</li>
<li>iinit: 初始化 inode 缓存</li>
<li>fileinit: 初始化文件系统</li>
<li>virtio_disk_init: 初始化磁盘</li>
</ul>
</li>
<li>userinit: 创建初始进程，并返回用户空间。这个初始进程定义在 initcode 中，它发起第一个系统调用，通过 exec 调用 init 程序。exec 系统调用由 sys_exec 函数处理，它将从用户空间读取参数并启动 init 进程。</li>
<li>init 进程配置控制台，调用 fork 启动 shell。</li>
<li>最后 shell 被执行，XV6 启动完成。</li>
</ol>
<p>所以，XV6 的启动过程可以概括为: 执行一系列初始化函数配置系统环境 -&gt; userinit 启动第一个用户进程 -&gt; 该进程执行 exec 系统调用启动 init 进程 -&gt; init 进程 fork 出 shell 进程 -&gt; shell 被执行，系统启动完成。</p>
<h2 id="lab2"><a class="anchor" href="#lab2">#</a> Lab2</h2>
<h3 id="system-call-tracing"><a class="anchor" href="#system-call-tracing">#</a> System call tracing</h3>
<ol>
<li>添加文件到 makefile</li>
</ol>
<pre><code class="language-makefile">	$U/_trace\
</code></pre>
<ol start="2">
<li>在<code>user/user.h</code>声明函数头文件；在<code>user/usys.pl</code>中添加存根；在<code>kernel/syscall.h</code>中添加系统调用的数值代号</li>
</ol>
<pre><code class="language-c">// user/user.h
int trace(int);

// user/usys.pl
entry(&quot;trace&quot;);

// kernel/syscall.h
#define SYS_trace  22
</code></pre>
<ol start="3">
<li>在 <code>kernel/syscall.c</code> 中添加声明；修改 <code>kernel/proc.c</code> 中的 proc 结构体，增加一个 mask 字段；在 <code>kernel/sysproc.c</code> 中实现 <code>sys_trace()</code> 函数。</li>
</ol>
<pre><code class="language-c">// syscall.c
extern uint64 sys_trace(void);

static uint64 (*syscalls[])(void) = {
...
    [SYS_trace] sys_trace,
};

// proc.c
struct proc {
...
  int mask;
};

// sysproc.c
uint64 sys_trace(void) {
  int mask;
  //从寄存器中取值
  if (argint(0, &amp;mask) &lt; 0) {
    return -1;
  }
  myproc()-&gt;mask = mask;
  return 0;
}
</code></pre>
<ol start="4">
<li>修改 <code>kernel/proc.c</code>中的<code>fork</code>函数，以从父进程复制到子进程的跟踪掩码</li>
</ol>
<pre><code class="language-c">//proc.c
int fork(void){
  ...
  np-&gt;mask = p-&gt;mask;
  ...
}
</code></pre>
<ol start="5">
<li>修改 <code>kernel/syscall.c</code> 中的 <code>syscall</code> 函数，打印输出</li>
</ol>
<pre><code class="language-c">void
syscall(void)
{
  int num;
  struct proc *p = myproc();

  num = p-&gt;trapframe-&gt;a7;
  if(num &gt; 0 &amp;&amp; num &lt; NELEM(syscalls) &amp;&amp; syscalls[num]) {
    p-&gt;trapframe-&gt;a0 = syscalls[num]();
    if ((1 &lt;&lt; num) &amp; p-&gt;mask) {
      printf(&quot;%d: syscall %s -&gt; %d\n&quot;, p-&gt;pid, syscalls[num], p-&gt;trapframe-&gt;a0);
    }
  } else {
    printf(&quot;%d %s: unknown sys call %d\n&quot;,
            p-&gt;pid, p-&gt;name, num);
    p-&gt;trapframe-&gt;a0 = -1;
  }
}
</code></pre>
<h3 id="sysinfo"><a class="anchor" href="#sysinfo">#</a> Sysinfo</h3>
<h2 id="3-"><a class="anchor" href="#3-">#</a> 3 虚拟内存</h2>
<p>虚拟内存是对物理内存的抽象，它提供虚拟地址空间到物理地址的映射，是计算机隔离性的重要环节之一。</p>
<p>现代计算机均通过某种方式对虚拟内存提供了硬件支持。</p>
<h3 id="31-"><a class="anchor" href="#31-">#</a> 3.1 地址空间</h3>
<h4 id="heading-12"><a class="anchor" href="#heading-12">#</a> 地址空间的必要性</h4>
<p>程序必须存在于物理内存当中，假若不具有隔离性，很可能会破坏其他应用程序甚至操作系统的正常运作。我们通过向每个程序提供独立的地址空间来实现必要的隔离性。</p>
<h3 id="32-"><a class="anchor" href="#32-">#</a> 3.2 页表</h3>
<h4 id="heading-13"><a class="anchor" href="#heading-13">#</a> 如何创建地址空间</h4>
<p>我们通过页表创建独立的地址空间。页表在硬件中通过处理器和内存管理单元实现。</p>
<p>对任何涉及地址的指令，其使用的均是虚拟地址。虚拟地址会被转到内存管理单元（MMU，Memory Management Unit）并翻译成物理地址，由得到的物理地址去索引物理内存。</p>
<h4 id="mmu-"><a class="anchor" href="#mmu-">#</a> MMU 如何翻译虚拟地址</h4>
<p>为了完成虚拟地址到物理地址的映射，MMU 需要在内存中保存一份表单，表单地址保存在 CPU 的寄存器中（在 RISC-V 中是 SATP 寄存器）。</p>
<p>每一个应用程序应当保存了一份自己的表单，在切换应用程序中，SATP 中的内容也必须做相应的切换。</p>
<h4 id="risc-v-"><a class="anchor" href="#risc-v-">#</a> RISC-V 中虚拟内存的实现</h4>
<p>虚拟地址和表单不是一对一的关系。在 RISC-V 中，一个 page 的大小是 4KB。</p>
<p>对于一个虚拟地址，它的内容分为 index 和 offset 两部分。MMU 通过 index 找到物理内存 page 号，通过 page 起始地址加上偏移量从而找到物理地址。</p>
<p>RISC-V 寄存器是 64 位，最大支持 64 位虚拟地址；但高 25 位并未使用，因此最大支持 2^39，即 512G 内存。其中 27 位作为 index，12 位作为 offset，对应 page 的 4096 字节。</p>
<p>RISC-V 最大支持 56 位物理地址，因此最大内存理论上最多能够到达 2^56 字节。其中 44 位物理 page 号，12 位 offset（直接从虚拟地址中拷贝）。</p>
<p>在 RISC-V 中，page-table 是一个多级结构。</p>
<p><img src="https://906337931-files.gitbook.io/~/files/v0/b/gitbook-legacy-files/o/assets%2F-MHZoT2b_bcLghjAOPsJ%2F-MKKjB2an4WcuUmOlE__%2F-MKPwJezGQDkWaLDRuDs%2Fimage.png?alt=media&amp;token=654cbddc-fab3-4180-8bd7-d275c63ae67f" alt=""></p>
<p>虚拟地址的 27 位 index 又细分为 L2、L1、L0，依次对应高、中、低级 page directory。每级 page directory 索引 512 个条目，每个条目（PTE）占 8 字节。在索引时，从高到低依次索引，然后在最低级的 page directory 中可得到实际物理地址。</p>
<p>分级结构很容易理解：通过将一个大的表单拆分多个小的表单，我们可以不索引许多没有用到的PTE，从而大大减少了内存开销。</p>
<p>一个 page directory 分为 44 位 PPN（page 起始地址）和 10 位标志位，其他 10 位作为拓展位留空。标志位包括：</p>
<ol>
<li>Valid：表明 PTE 是否合法，合法（被使用）的 Valid 置一，否则置零。</li>
<li>Readable 和 Writable，表明是否可读写 page</li>
<li>Executable：是否可从该 page 执行指令</li>
<li>User：是否可被用户空间进程访问</li>
<li>其他：不重要</li>
</ol>
<h3 id="33-"><a class="anchor" href="#33-">#</a> 3.3 页表缓存</h3>
<p>三级寻址需要三次内存读取，因此代价较高，所以需要缓存最近读取过的内存地址，该技术称为页表缓存（TLB，Translation Lookside Buffer）。</p>
<p>TLB 会保存查询到的虚拟地址到物理地址的映射关系，在下一次访问同一虚拟地址时可直接从 TLB 中查取，从而避免查询 page table。在 table page 切换后 TLB 也会清空（RISC-V 中通过 sfence_vma 指令）。</p>
<h3 id="34-xv6-"><a class="anchor" href="#34-xv6-">#</a> 3.4 xv6 页表实现</h3>
<h4 id="heading-14"><a class="anchor" href="#heading-14">#</a> 物理内存分布</h4>
<p>物理地址寻址由具体主板决定，一般来说，从某个物理地址分隔（教程中是 0x80000000），以上是从 DRAM 寻址，以下是 I/O 设备。</p>
<p><img src="https://906337931-files.gitbook.io/~/files/v0/b/gitbook-legacy-files/o/assets%2F-MHZoT2b_bcLghjAOPsJ%2F-MK_UbCc81Y4Idzn55t8%2F-MKaeaT3eXOyG4jfKKU7%2Fimage.png?alt=media&amp;token=a04af08d-3c8d-4c61-a63d-6376dec252ea" alt=""></p>
<p>上电后，主板运行 boot ROM 中的代码，然后跳转到 0x80000000，从而启动操作系统。</p>
<h4 id="xv6--1"><a class="anchor" href="#xv6--1">#</a> xv6 虚拟地址空间</h4>
<p>处于简单考虑，在 xv6 中，虚拟地址和物理地址的映射是相等映射。但是，虚拟地址和物理地址之间的映射关系可能是一对一、一对多、多对一。</p>
<p>我们还可以为 page table 设置权限，从而提早发现和处理 bug。</p>
<h3 id="35-kvminit-"><a class="anchor" href="#35-kvminit-">#</a> 3.5 kvminit 函数</h3>
<p>kvminit 函数设置地址空间。其结构如下：</p>
<p><img src="https://906337931-files.gitbook.io/~/files/v0/b/gitbook-legacy-files/o/assets%2F-MHZoT2b_bcLghjAOPsJ%2F-MKgiYv2CppKnuZEsKO3%2F-MKjcMW3TzZ3kdPwse0X%2Fimage.png?alt=media&amp;token=080b793a-f859-479b-aa53-20dec81d4e88" alt=""></p>
<ol>
<li>代码的最上方为最高级 page 分配内存，并将内存置零</li>
<li><code>kvmmap</code> 函数将 I/O 设备映射到内核</li>
<li>vmprint 打印当前的 kernel page table</li>
</ol>
<h3 id="36-kvminithart-"><a class="anchor" href="#36-kvminithart-">#</a> 3.6 kvminithart 函数</h3>
<p>kvminithart 函数运行在 kvminit 函数之后。</p>
<p><img src="https://906337931-files.gitbook.io/~/files/v0/b/gitbook-legacy-files/o/assets%2F-MHZoT2b_bcLghjAOPsJ%2F-MKgiYv2CppKnuZEsKO3%2F-MKjffmTgmjxQO-BCcin%2Fimage.png?alt=media&amp;token=050d4673-2526-43c7-83aa-6b623e840074" alt=""></p>
<p>kvminithart 的作用是告知内核使用已经设置好的 page table，在此之后虚拟内存开始工作。</p>
<h2 id="4-risc-v-"><a class="anchor" href="#4-risc-v-">#</a> 4 RISC-V 调用约定和栈结构</h2>
<h3 id="41-c-"><a class="anchor" href="#41-c-">#</a> 4.1 C 程序到汇编的转换</h3>
<p>C 程序无法直接被计算机理解。计算机能够理解的是二进制代码，或者说 ISA（指令集）所对应的汇编语言。因此，需要将 C 程序经过编译（包括编译、汇编、链接等）变成汇编语言。</p>
<h3 id="42-risc-v--x86"><a class="anchor" href="#42-risc-v--x86">#</a> 4.2 RISC-V 和 x86</h3>
<p>RISC-V 是一种精简指令集（RISC，Reduced Instruction Set Computer），而 x86 是复杂指令集（CISC，Complex Instruction Set Computer）。两者主要区别如下：</p>
<ol>
<li>RISC-V 指令数量远小于 x86，x86存在历史包袱；</li>
<li>RISC-V 指令更加简单（封装程度低）；</li>
<li>RISC-V 是唯一的开源指令集；</li>
</ol>
<h3 id="43-risc-v-"><a class="anchor" href="#43-risc-v-">#</a> 4.3 RISC-V 寄存器</h3>
<p>RISC-V寄存器结构如下：</p>
<p><img src="https://906337931-files.gitbook.io/~/files/v0/b/gitbook-legacy-files/o/assets%2F-MHZoT2b_bcLghjAOPsJ%2F-MM-XjiGboAFe-3YvZfT%2F-MM0rYc4eVnR9nOesAAv%2Fimage.png?alt=media&amp;token=f30ebac8-8dc0-4b5d-8aa7-b241a10b43b3" alt=""></p>
<p>汇编代码运行在寄存器上，寄存器是运算和数据读取的最快方式。</p>
<p>第一列寄存器名称只在 Compressed Instruction（16bit）中有用，在其他地方使用 ABI 名称进行调用。</p>
<p>a0-7 寄存器保存函数参数，当参数数量大于寄存器数量时需要使用内存，因此会降低效率。</p>
<p>我们可以从 Saver 列查看寄存器的 Saver 类型，它有两个可能的值：Caller 和 Callee。其中 Caller 寄存器在函数调用时不会保存，也就是说它可以被调用函数重写。</p>
<h3 id="44-"><a class="anchor" href="#44-">#</a> 4.4 栈</h3>
<p>每次调用函数都会产生一个栈帧。它通过栈指针分配内存。由于栈帧是从高地址到低地址，因此当创建一个栈帧时对地址做减法。</p>
<p><img src="https://906337931-files.gitbook.io/~/files/v0/b/gitbook-legacy-files/o/assets%2F-MHZoT2b_bcLghjAOPsJ%2F-MM3Hk7Gv6ibvM2lxjCc%2F-MM4D2J3t3ajqkngxRPC%2Fimage.png?alt=media&amp;token=1f78ffd1-9322-4666-85f2-8aa831ced49e" alt=""></p>
<p>栈帧中有两个重要的寄存器：fp 指向栈帧顶部，sp 指向栈帧底部。</p>
<p>一个栈帧中的第一位保存着自己的返回地址，然后是指向前一个栈帧的指针，以便函数返回。返回地址保存在 sp 寄存器中，指向前一个栈帧的指针保存在 fp 寄存器中。</p>
<p><img src="https://906337931-files.gitbook.io/~/files/v0/b/gitbook-legacy-files/o/assets%2F-MHZoT2b_bcLghjAOPsJ%2F-MM4GlTfQa57FRIbUhP2%2F-MM57e54ANIFdXpVubXH%2Fimage.png?alt=media&amp;token=e9b9b85d-5862-4825-8b7c-7be342636a77" alt=""></p>
<p>上面的函数调用了一个名为 <code>sum_to</code> 的函数，因此必须包含 prologue：首先将 sp 寄存器减 16 以创建一个新的栈帧，然后将返回地址保存在 sp。</p>
<p><img src="https://906337931-files.gitbook.io/~/files/v0/b/gitbook-legacy-files/o/assets%2F-MHZoT2b_bcLghjAOPsJ%2F-MM4GlTfQa57FRIbUhP2%2F-MM58TOs_9kQtfl4bVPw%2Fimage.png?alt=media&amp;token=9fd14608-4f97-4fef-9ef7-4df05502fd5a" alt=""></p>
<p>在函数调用的最后加载返回地址到 ra 寄存器，然后对栈指针加 16 以删除创建的栈帧。</p>
<h3 id="45-"><a class="anchor" href="#45-">#</a> 4.5 结构体的结构</h3>
<p>结构体在内存中是一段连续的地址，类似于一个数组，但每个字段的类型不需要相同。</p>
<h2 id="5-"><a class="anchor" href="#5-">#</a> 5 隔离与系统调用的进入和退出</h2>
<h3 id="51-trap"><a class="anchor" href="#51-trap">#</a> 5.1 Trap</h3>
<p>用户空间和内核空间的切换成为 trap，它发生在：</p>
<ol>
<li>系统调用</li>
<li>发生 page fault 或除零错误</li>
<li>中断</li>
</ol>
<h4 id="trap-"><a class="anchor" href="#trap-">#</a> trap 流程</h4>
<ol>
<li>保存 32 个用户寄存器，以便在调用完成后恢复原来状态</li>
<li>保存 pc （程序寄存器）</li>
<li>更改 mode 标志位为 supervisor mode，以读写控制寄存器</li>
<li>SATP 寄存器保存 page table 的物理地址，需要将其从 user page table 切换到 kernel page table</li>
<li>将堆栈寄存器（fp、sp）指向内核中的地址以调用内核代码</li>
<li>跳转到内核空间</li>
</ol>
<h3 id="52-trap-"><a class="anchor" href="#52-trap-">#</a> 5.2 Trap 代码执行流程</h3>
<p>以 write 函数为例，它调用 ecall 切换到内核空间：</p>
<ol>
<li>调用 uservec 函数</li>
<li>调用 usertrap 函数</li>
<li>执行 syscall，找到并调用 sys_write，打印到控制台并返回到 usertrap 函数</li>
<li>usertrap 在最后执行 usertrapret，完成返回用户空间的部分准备工作</li>
<li>执行 userret 函数</li>
</ol>
<h2 id="6-page-faults"><a class="anchor" href="#6-page-faults">#</a> 6 Page faults</h2>
<h3 id="61-page-fault-"><a class="anchor" href="#61-page-fault-">#</a> 6.1 page fault 基础</h3>
<p>虚拟内存的主要优点是：虚拟内存提供了应用之间以及用户空间与内核空间之间的隔离性；另外，虚拟内存提供了一层抽象，实现了虚拟地址和物理地址之间的动态映射。</p>
<p>page fault 能够动态更新 page table，我们能够利用 page fault 进行一些操作系统的优化行为。响应 page fault 需要记录以下几个信息：</p>
<ol>
<li>触发 page fault 的源，也就是引起错误的虚拟内存地址。当 page fault 被触发，会进入 trap，并将错误地址保存在 STVAL 寄存器中。</li>
<li>出错的原因。即 trap 中状态切换的原因，用数字代号表示，保存在 SCAUSE 寄存器中。</li>
<li>触发 page fault 的指令地址，即发生错误的程序计数器的值，标志 page fault 在用户空间发生的位置，以便修复 page table 后可以恢复中断的指令。存储在 SEPC 寄存器以及 <code>trapframe-&gt;epc</code> 中。</li>
</ol>
<h3 id="62-"><a class="anchor" href="#62-">#</a> 6.2 懒内存分配</h3>
<p><img src="https://906337931-files.gitbook.io/~/files/v0/b/gitbook-legacy-files/o/assets%2F-MHZoT2b_bcLghjAOPsJ%2F-MMSxponnGmjT-9o9zTI%2F-MMSxrQomWtds7XdFzKH%2Fimage.png?alt=media&amp;token=e580c883-0c0a-4370-852e-393c05cd2fc1" alt=""></p>
<p>在 RISC-V 中使用 sbrk 系统调用进行应用程序的内存分配。在应用程序启动时，sbrk 指向 heap 的底部，也就是 stack 的顶部，由 p-&gt;sz 标志。sbrk 接受一个整数参数，指示分配的字节数（页数？），以扩大 heap。</p>
<p>sbrk 默认的机制是 eager allocation，即积极的分配策略，在调用时立刻分配内存。但这非常容易造成内存浪费的问题。因此我们可以利用 page fault 实现 lazy allocation。</p>
<p>懒分配是指不立即分配内存，而是在发生由于内存未分配造成的 page fault 时执行 handler：使用 kalloc 分配一个内存 page，使用 0 填充内容以初始化并映射到 user page table，然后重新执行指令。</p>
<p>原始的 sbrk 函数如下，它将 <code>p-&gt;sz</code> 加 n 并分配内存：</p>
<p><img src="https://906337931-files.gitbook.io/~/files/v0/b/gitbook-legacy-files/o/assets%2F-MHZoT2b_bcLghjAOPsJ%2F-MMhf55_kv7MwKoDReP9%2F-MMi5nltOEPL47k3aWDy%2Fimage.png?alt=media&amp;token=d30677d3-76c2-4899-904d-1c888014dd92" alt=""></p>
<p>而我们只想让其加 n，但不分配内存：</p>
<p><img src="https://906337931-files.gitbook.io/~/files/v0/b/gitbook-legacy-files/o/assets%2F-MHZoT2b_bcLghjAOPsJ%2F-MMhf55_kv7MwKoDReP9%2F-MMi6ZfF398jK09BDzuh%2Fimage.png?alt=media&amp;token=132d7da6-0da5-466e-a3d5-4c54aafa8261" alt=""></p>
<p>这样就会如期发生 page fault，我们在 usertrap 函数中对其 (SCAUSE=15) 进行处理，为其分配内存，若无物理内存则 kill 进程：</p>
<p><img src="https://906337931-files.gitbook.io/~/files/v0/b/gitbook-legacy-files/o/assets%2F-MHZoT2b_bcLghjAOPsJ%2F-MMiBlrqE-q1_u5-VWpo%2F-MMiVmy1jHsocOlJC1gG%2Fimage.png?alt=media&amp;token=b162b795-3ed8-45c8-bac7-76c4cb5d4919" alt=""></p>
<h3 id="63-zero-fill-on-demand"><a class="anchor" href="#63-zero-fill-on-demand">#</a> 6.3 Zero-Fill-On-Demand</h3>
<p>用户程序的地址空间中存在 data、text、bss 三个区块，其中，text 存放程序指令，data 区域存放已初始化的全局变量，bss 包含未初始化或初始化为 0 的全局变量。</p>
<p>在程序初始化时，我们需要分配许多内容为 0 的 page。通过使用按需分配策略，可以只初始化一个全零的物理 page，同时将虚拟地址空间挂载到这个物理 page 之上。这个 page 应当是只读的。在尝试读写这个 page 时，会发生 page fault，我们在 handler 中新分配一个全零的 page，并重新进行操作。</p>
<p>它带来的好处是我们不需要在一开始就为应用程序分配大量内存，它能够减少内存的用量，同时加快应用程序的启动速度。但是 page fault 处理会增加一定成本。</p>
<h3 id="64-cow-fork"><a class="anchor" href="#64-cow-fork">#</a> 6.4 COW Fork</h3>
<p>COW Fork 即 Copy-On-Write Fork，它使用写时复制策略。它尝试解决的问题是：当我们同时调用 fork 和 exec 时，fork 会创建新的 page，并将父进程的 page 拷贝到子进程 page 当中；但执行 exec 后，它又会抛弃这些 page（也就是说这部分内存不会被修改），并分配新的 page 来执行新的指令内容。</p>
<p>COW Fork 所做的就是让子进程共享父进程物理内存 page，也就是设置子进程的 PTE 指向父进程的物理内存 page。出于隔离性考虑，我们将子进程和父进程的 PTE 均设置为只读。因此，当尝试更改内存内容时会发生 page fault。这时可以为子进程创建新的 page，该 page 只对子进程可见，而原 page 对父进程可读写。</p>
<h3 id="65-demanding-paging"><a class="anchor" href="#65-demanding-paging">#</a> 6.5 Demanding Paging</h3>
<p>在 exec 执行后，需要加载内存的 data 和 text 到 page 中。操作系统默认使用 eager 的方式进行加载。demanding paging 也就是事先在虚拟空间中分配好 data 和 text 的地址段，但不对应任何实际的物理地址，即将 PTE 的 valid bit 设为 0。</p>
<p>当应用程序从地址 0 开始执行，当遇到 on-demand page 时会触发 page fault，这时我们从内存中读取程序 page 数据，然后将其映射到 page table 再重新执行。</p>
<p>当不是全部的 data 和 text 被用到时，通过这种方式我们可以节省内存的使用，同时加快程序的运行速度。</p>
<p>当物理内存耗尽时，一种方法是撤回 page，也就是将其写回文件系统，并释放该 page。</p>
<p>我们通常使用 LRU（Least Recently Used）策略决定将要撤回的 page。page 分为 dirty 和 non-dirty page：dirty page 曾经被写，而 non-dirty page 只被读过。我们比较倾向选择 non-dirty page，因为 dirty page 需要再次被写回到内存中，因而对其写的成本更高。</p>
<p>在 PTE 中的 RSW 寄存器中存有 Dirty 和 Access bit，这两个 bit 标志该 PTE 是否是 dirty 以及在何时被访问过，因此可以用 Access bit 来决定 LRU 排名。</p>
<h3 id="66-memory-mapped-files"><a class="anchor" href="#66-memory-mapped-files">#</a> 6.6 Memory Mapped Files</h3>
<p>我们会面临将文件加载到内存中对其处理的场合，由 mmap 系统调用函数提供。而使用 eager 策略将其加载到内存中的代价往往较高，因此操作系统一般采用懒加载策略。</p>
<p>mmap 接受一个虚拟地址（VA）、长度（len）、保护、标志位、文件描述符和偏移量，表示从文件描述符对应的文件的偏移量的位置开始，映射长度为 len 的内容到虚拟内存地址 VA，同时我们需要加上一些保护，比如只读或者读写。</p>
<p>具体实现中，我们使用 VMA（Virtual Memory Area）结构体保存文件描述符、偏移量等，以记录虚拟内存地址对应的实际内容位置。当发生 page fault 时，将磁盘数据读取到内存中。</p>
<h2 id="7-"><a class="anchor" href="#7-">#</a> 7 中断</h2>
<h3 id="71-"><a class="anchor" href="#71-">#</a> 7.1 真实操作系统实际内存使用情况</h3>
<p>真实操作系统中大多数内存被使用，除应用程序用量外，大多数的内存被 buff/cache 占用。当需要使用新的内存时，往往需要从已使用的内存中撤回部分内存以重新利用。</p>
<p>在实际使用中，VIRT（虚拟内存）要远大于 RES（实际使用内存），因此 demand paging 等优化很有必要。</p>
<h3 id="72-"><a class="anchor" href="#72-">#</a> 7.2 中断硬件部分</h3>
<p>当中断发生时，操作系统需要保存当前工作，处理中断，然后恢复原先的工作；在这个意义上，中断与系统调用以及 page fault 的处理很类似。但中断有其特殊性：</p>
<ol>
<li>中断与 CPU 当前执行的任务无关。</li>
<li>CPU 与中断发生的设备并行运行。</li>
</ol>
<p>外设连接到 CPU，CPU 通过 PLIC（Platform Level Interrupt Control）处理外设的中断。PLIC 路由中断到 CPU 的一个核以进行处理，当处理完毕，CPU 会通知 PLIC；当没有空闲的核时，PLIC 保留中断直至被处理。</p>
<h3 id="73-"><a class="anchor" href="#73-">#</a> 7.3 设备驱动</h3>
<p>驱动即内核中用以管理设备的代码，一般分为 bottom 和 top 两部分。</p>
<p>bottom 是中断 handler，由 CPU 调用以处理中断；top 是供用户进程及内核其他部分调用的接口。</p>
<p>驱动中存在 buffer，bottom/top 均会向 buffer 中读写数据。</p>
<p>对驱动编程即找到设备在物理地址空间上的位置，并使用 store/load 对其进行操作和控制。</p>
<h3 id="74-xv6-"><a class="anchor" href="#74-xv6-">#</a> 7.4 xv6 中的中断</h3>
<p>RISC-V 有如下与中断相关的寄存器：</p>
<ol>
<li>SIE（Supervisor Interrupt Enable），S 负责软件中断，I 负责定时器中断，E 负责外设中断。</li>
<li>SSTATUS（Supervisor Status），可用来控制关闭和打开中断</li>
<li>SIP（Supervisor Interrupt Pending），用来判断中断的类型</li>
<li>SCAUSE：标志 trap 发生原因是中断或其他</li>
<li>STVEC：trap 发生的位置，以便完成后恢复</li>
</ol>
<h4 id="heading-15"><a class="anchor" href="#heading-15">#</a> 中断处理代码</h4>
<ol>
<li><code>start</code> 函数中将中断设置在 supervisor 模式，然后设置 SIE 寄存器接收中断，再初始化定时器。</li>
</ol>
<p><img src="https://906337931-files.gitbook.io/~/files/v0/b/gitbook-legacy-files/o/assets%2F-MHZoT2b_bcLghjAOPsJ%2F-MNYn8xQ_nM7UyU1sa-g%2F-MNa5Rv4ANj0GOmpMXf9%2Fimage.png?alt=media&amp;token=99fa1a9b-b983-46ec-9c0f-616220592cd9" alt=""></p>
<ol start="2">
<li>在<code>main</code>函数中处理中断</li>
</ol>
<p><img src="https://906337931-files.gitbook.io/~/files/v0/b/gitbook-legacy-files/o/assets%2F-MHZoT2b_bcLghjAOPsJ%2F-MNYn8xQ_nM7UyU1sa-g%2F-MNa6N7vHde52fObSxUz%2Fimage.png?alt=media&amp;token=65580d62-73c5-46eb-8767-e2fde2daac36" alt=""></p>
<ol start="3">
<li>处理 consoleinit。初始化锁，然后初始化uart</li>
</ol>
<p><img src="https://906337931-files.gitbook.io/~/files/v0/b/gitbook-legacy-files/o/assets%2F-MHZoT2b_bcLghjAOPsJ%2F-MNYn8xQ_nM7UyU1sa-g%2F-MNa6mHXaOc6Dtv5U6bj%2Fimage.png?alt=media&amp;token=80ea954c-2230-4eba-adcf-1a8e386bdb4a" alt=""></p>
<ol start="4">
<li>初始化uart。关闭中断，设置波特率，设置字符长度为8，重置FIFO，开启中断。之后uart可以生成中断。</li>
</ol>
<p><img src="https://906337931-files.gitbook.io/~/files/v0/b/gitbook-legacy-files/o/assets%2F-MHZoT2b_bcLghjAOPsJ%2F-MNYn8xQ_nM7UyU1sa-g%2F-MNa7OdMH3taGmHfE7Wj%2Fimage.png?alt=media&amp;token=0538d371-3758-431d-98e6-907f5f5a6ab9" alt=""></p>
<ol start="5">
<li>初始化 plic。决定 plic 接收哪些中断并路由。</li>
</ol>
<p><img src="https://906337931-files.gitbook.io/~/files/v0/b/gitbook-legacy-files/o/assets%2F-MHZoT2b_bcLghjAOPsJ%2F-MNa7TJFrEQk2gYzkwCG%2F-MNcl8NhzO719lb6xtPl%2Fimage.png?alt=media&amp;token=ceb45ee2-8509-48fb-9166-7d6bc9930fef" alt=""></p>
<ol start="6">
<li>使用plicinithart决定对哪些中断感兴趣</li>
</ol>
<p><img src="https://906337931-files.gitbook.io/~/files/v0/b/gitbook-legacy-files/o/assets%2F-MHZoT2b_bcLghjAOPsJ%2F-MNa7TJFrEQk2gYzkwCG%2F-MNcmoGEKLSU8ifrGFC6%2Fimage.png?alt=media&amp;token=4bbb1a15-4f10-427c-961e-51b801adf8ef" alt=""></p>
<ol start="7">
<li>调用scheduler函数以设置SSTATUS寄存器，使CPU能够接受中断</li>
</ol>
<p><img src="https://906337931-files.gitbook.io/~/files/v0/b/gitbook-legacy-files/o/assets%2F-MHZoT2b_bcLghjAOPsJ%2F-MNa7TJFrEQk2gYzkwCG%2F-MNcnlTuggw_Il7m9iIW%2Fimage.png?alt=media&amp;token=ac9df287-e059-4438-957e-548f1b22e030" alt=""></p>
<p><img src="https://906337931-files.gitbook.io/~/files/v0/b/gitbook-legacy-files/o/assets%2F-MHZoT2b_bcLghjAOPsJ%2F-MNa7TJFrEQk2gYzkwCG%2F-MNcoC3QhbWZHXRz2BEt%2Fimage.png?alt=media&amp;token=eca193c8-ff3d-4d96-b837-5cfbbc2b2ecc" alt=""></p>
<h3 id="75-uart--top"><a class="anchor" href="#75-uart--top">#</a> 7.5 UART 驱动 top</h3>
<p>以 shell 输出提示符 <code>$</code> 到 console 为例：</p>
<ol>
<li>在 main 函数中同过 mkmod 系统调用创建 console，再通过 dup 创建 stdout 和 stderr，从而得到三个指向 console 的文件描述符 0、1、2。</li>
</ol>
<p><img src="https://906337931-files.gitbook.io/~/files/v0/b/gitbook-legacy-files/o/assets%2F-MHZoT2b_bcLghjAOPsJ%2F-MNa7TJFrEQk2gYzkwCG%2F-MNcplHF86eYTpFW_ztO%2Fimage.png?alt=media&amp;token=e445273b-fd4d-4b8f-ad9a-100f621a2b62" alt=""></p>
<ol start="2">
<li>shell 打开 console 的文件描述符，向文件描述符 2 打印 <code>$</code>。</li>
</ol>
<p><img src="https://906337931-files.gitbook.io/~/files/v0/b/gitbook-legacy-files/o/assets%2F-MHZoT2b_bcLghjAOPsJ%2F-MNa7TJFrEQk2gYzkwCG%2F-MNcqqRtbogpSiiEpc2P%2Fimage.png?alt=media&amp;token=a1ae7eb6-b01d-4886-93ba-771f0bbe4182" alt=""></p>
<ol start="3">
<li>上一步中的 <code>fprintf</code> 发起系统调用 <code>write</code>，由 <code>filewrite</code> 判断是设备类型，最终调用 <code>consolewrite</code> 函数。<code>either_copyin</code> 拷入字符，使用 <code>uartputc</code> 写给 UART 设备。</li>
</ol>
<p><img src="https://906337931-files.gitbook.io/~/files/v0/b/gitbook-legacy-files/o/assets%2F-MHZoT2b_bcLghjAOPsJ%2F-MNa7TJFrEQk2gYzkwCG%2F-MNctcQci75CDpfVpdRq%2Fimage.png?alt=media&amp;token=08880b86-4d8f-4b67-aa3c-cc5ce6cb17b0" alt=""></p>
<ol start="4">
<li>uart中定义了一个环形buffer。<code>uartputc</code>函数中先判断环形buffer是否已满，若已满则sleep一段时间以让出CPU，否则将数据写入buffer，然后调用<code>uartstart</code>函数。</li>
</ol>
<p><img src="https://906337931-files.gitbook.io/~/files/v0/b/gitbook-legacy-files/o/assets%2F-MHZoT2b_bcLghjAOPsJ%2F-MNa7TJFrEQk2gYzkwCG%2F-MNcudamCocCj7PtfYpv%2Fimage.png?alt=media&amp;token=f9ff4004-3b5d-4c5a-bbf2-676d10dc2033" alt=""></p>
<p><img src="https://906337931-files.gitbook.io/~/files/v0/b/gitbook-legacy-files/o/assets%2F-MHZoT2b_bcLghjAOPsJ%2F-MNa7TJFrEQk2gYzkwCG%2F-MNcu9oxFUI2qpie5z4T%2Fimage.png?alt=media&amp;token=b0201ce3-225c-4696-a5e4-348e1b081bcc" alt=""></p>
<ol start="5">
<li><code>uartstart</code>通知设备执行操作。首先检测设备是否空闲，若空闲则从buffer中读取数据并写入THR（Transmission Holding Register）寄存器以发送数据。当数据到达设备，系统调用返回。</li>
</ol>
<p><img src="https://906337931-files.gitbook.io/~/files/v0/b/gitbook-legacy-files/o/assets%2F-MHZoT2b_bcLghjAOPsJ%2F-MNcv-xytcPNjgcA09N-%2F-MNfDMD08BsxVVcKpVl3%2Fimage.png?alt=media&amp;token=58e70d9b-7dd2-46bb-8243-bb188dcb8307" alt=""></p>
<h3 id="76-uart-bottom"><a class="anchor" href="#76-uart-bottom">#</a> 7.6 UART驱动 bottom</h3>
<p>当一个中断由 PCIE 发送给 CPU：</p>
<ol>
<li>清楚 SIE 相应位的 bit，以防止被其他中断打断。</li>
<li>设置 SEPT 寄存器为当前 pc，以便之后恢复</li>
<li>保存当前 mode（如 user mode）</li>
<li>将 mode 设置为 Supervisor mode</li>
<li>将 pc 置为 STVEC 的值（即 trap 处理程序的地址），进入usertrap</li>
<li><code>usertrap</code> 调用 <code>devintr</code>，通过 SCAUSE 判断是否来自外设的中断，然后使用 <code>plic_claim</code> 获取中断。</li>
</ol>
<p><img src="https://906337931-files.gitbook.io/~/files/v0/b/gitbook-legacy-files/o/assets%2F-MHZoT2b_bcLghjAOPsJ%2F-MNfH5qMvmyxhegTFSUo%2F-MNpcUmolzUjQhGtVWpo%2Fimage.png?alt=media&amp;token=a894536b-a241-4230-8c0e-300d556275b6" alt=""></p>
<ol start="7">
<li><code>plic_clame</code> 函数中 CPU 告知 PLIC 自己要处理中断，返回中断号</li>
</ol>
<p><img src="https://906337931-files.gitbook.io/~/files/v0/b/gitbook-legacy-files/o/assets%2F-MHZoT2b_bcLghjAOPsJ%2F-MNfH5qMvmyxhegTFSUo%2F-MNpdQCYQP1Gcv_HTm7o%2Fimage.png?alt=media&amp;token=3dca463c-486f-4c96-87da-bc8401a65e94" alt=""></p>
<ol start="8">
<li>若接收到的是 UART 中断，则调用 <code>uartintr</code> 函数，从 UART 的接受寄存器中读取数据，然后将数据传给 <code>consoleintr</code></li>
</ol>
<p><img src="https://906337931-files.gitbook.io/~/files/v0/b/gitbook-legacy-files/o/assets%2F-MHZoT2b_bcLghjAOPsJ%2F-MNfH5qMvmyxhegTFSUo%2F-MNpeCI5zYrIAIDEUzeD%2Fimage.png?alt=media&amp;token=796177bb-eeb4-45d8-8502-2c60fac1b5ec" alt=""></p>
<h3 id="77-"><a class="anchor" href="#77-">#</a> 7.7 中断相关并发</h3>
<p>中断相关的并发包括以下几类：</p>
<ol>
<li>设备与 CPU 并行。称为 producer-consumer 并行。</li>
<li>中断停止当前程序运行。中断不仅会打断用户空间代码，也有可能打断内核空间代码，而内核空间代码某些不应该被打断。</li>
<li>驱动的 top 和 bottom 并行执行。这也意味着它们可以在两个 CPU 上执行，需要通过锁来共享数据。</li>
</ol>
<p>驱动中包含一个环形buffer，大小为32个字节，它有两个指针：读指针和写指针。当向buffer中写入数据时写指针加，读数据时读指针加；两指针相等时表示buffer是空的。</p>
<p>producer-consumer 并发中，producer（在示例中是 uartputc）可以一直向 buffer 中写入数据，直到 buffer 满了，暂时 sleep；consumer，即中断 handler 函数（在示例中是 uartintr）当发生中断时从 buffer 中读数据，直到 buffer 为空。</p>
<h3 id="78-"><a class="anchor" href="#78-">#</a> 7.8 中断的演进</h3>
<p>当一个快设备的场合，中断发生过快以至超出 CPU 的处理能力，这时我们往往使用 polling（轮询）；而对慢设备使用中断。在一些场合可以动态切换轮询和中断（如网卡的 NAPI）。</p>
<h2 id="8-"><a class="anchor" href="#8-">#</a> 8 多线程和锁</h2>
<h3 id="81-"><a class="anchor" href="#81-">#</a> 8.1 为什么要使用锁</h3>
<h4 id="heading-16"><a class="anchor" href="#heading-16">#</a> 为何我们倾向于使用多线程提高性能</h4>
<p>自2000年开始，CPU的时钟频率几乎不再增加，因此CPU的单线程达到了一个极限；而CPU的晶体管数量持续增加，因此我们倾向使用多核的方式提高计算机性能。</p>
<h4 id="heading-17"><a class="anchor" href="#heading-17">#</a> 锁的优缺点</h4>
<p>当我们同时使用多个核时，需要使用锁来协调多线程时数据的更新，以确保共享数据的正确性以及避免 race condition 的发生。</p>
<p>但是锁同时也会带来性能损失，使程序再次变成串行。</p>
<h3 id="82--race-condition"><a class="anchor" href="#82--race-condition">#</a> 8.2 锁如何避免 race condition</h3>
<h4 id="heading-18"><a class="anchor" href="#heading-18">#</a> 什么是锁</h4>
<p>锁即是一个对象，它有两个方法：</p>
<ol>
<li>acquire。acquire 接受一个指向 lock 的指针，表示获得一个锁。同一时间只能有一个进程获得锁。</li>
<li>release。release 同样接受一个指向 lock 的指针，表示释放一个锁。在锁被释放之前，其他尝试获得锁的进程阻塞。</li>
</ol>
<p>在锁获得之后、被释放之前，这之间的代码区域被称为 Criticle section，它通常会原子性地更新数据。</p>
<h3 id="83-"><a class="anchor" href="#83-">#</a> 8.3 什么时候使用锁</h3>
<p>当两个进程共享同一数据结构，且其中一个进程想要更改共享的数据结构时需要加锁。</p>
<h3 id="84-"><a class="anchor" href="#84-">#</a> 8.4 锁的特性和死锁</h3>
<h4 id="heading-19"><a class="anchor" href="#heading-19">#</a> 锁的特性</h4>
<ol>
<li>避免丢失数据更新</li>
<li>打包多个操作，使其具有原子性</li>
<li>维护共享数据的不变性</li>
</ol>
<h4 id="heading-20"><a class="anchor" href="#heading-20">#</a> 死锁</h4>
<p>死锁即由于锁的原因导致程序永远阻塞。</p>
<p>最简单的死锁是重复获得一个未被释放的锁。对于多个 CPU 的场合，由于锁的获得和释放的顺序不正确，可能导致 deadly embrace，即两个或更多进程间因互相等待锁的释放而造成的死锁。</p>
<p>因此我们需要以合理的顺序获得和释放锁，这要求对锁进行排序，但该操作又会破坏程序的模块化。</p>
<h3 id="85-xv6-"><a class="anchor" href="#85-xv6-">#</a> 8.5 xv6 自旋锁的实现</h3>
<h4 id="heading-21"><a class="anchor" href="#heading-21">#</a> 自旋锁的结构</h4>
<p>xv6中自旋锁的定义如下：</p>
<p><img src="https://906337931-files.gitbook.io/~/files/v0/b/gitbook-legacy-files/o/assets%2F-MHZoT2b_bcLghjAOPsJ%2F-MPS4AMuEHdeXFZVa2tv%2F-MPTKBMvidl5JDe89V15%2Fimage.png?alt=media&amp;token=b9427226-3928-4e4d-a1cc-04c13641fe75" alt=""></p>
<p>locked 表明是否上锁，name 是锁的名称，cpu 表示当前锁被哪个 cpu 持有。</p>
<h4 id="heading-22"><a class="anchor" href="#heading-22">#</a> 获取锁</h4>
<p><img src="https://906337931-files.gitbook.io/~/files/v0/b/gitbook-legacy-files/o/assets%2F-MHZoT2b_bcLghjAOPsJ%2F-MPS4AMuEHdeXFZVa2tv%2F-MPTLYWRF8Z7xnWXnrs2%2Fimage.png?alt=media&amp;token=03319722-1193-4ab4-bb36-23dbc3c11fae" alt=""></p>
<p>获取锁的最大挑战是保证设置 locked 字段的操作的原子性，这时由 amoswap 指令实现的。它接受一个地址和两个寄存器r1，r2。它会先锁定地址，将地址中的数据保存到一个临时变量，然后将r1中的数据写入地址，再将临时变量中的数据写入r2，最后解锁地址。</p>
<p>在流程中最重要的是 <code>lock_test_and_set</code> 循环。该函数实现了 atomic swap 操作：若锁未被持有，则 locked 字段为 0，这时将其设为 1，然后返回原数值 0，退出循环；若锁被持有，则 locked 字段为 1，这时再次对其写入 1，返回原数值 1，继续循环。</p>
<p><img src="https://906337931-files.gitbook.io/~/files/v0/b/gitbook-legacy-files/o/assets%2F-MHZoT2b_bcLghjAOPsJ%2F-MPS4AMuEHdeXFZVa2tv%2F-MPTNUkQSugrjhscfd94%2Fimage.png?alt=media&amp;token=e67cecca-85fa-4c2e-9040-441dd85fdfd0" alt=""></p>
<h4 id="heading-23"><a class="anchor" href="#heading-23">#</a> 释放锁</h4>
<p><img src="https://906337931-files.gitbook.io/~/files/v0/b/gitbook-legacy-files/o/assets%2F-MHZoT2b_bcLghjAOPsJ%2F-MPTWI4LYcl0jB6hDkgX%2F-MPU8Xm8AmqsNVAEAaKb%2Fimage.png?alt=media&amp;token=ed3441cc-6193-45b1-9570-91d4d060aa0e" alt=""></p>
<p><code>lock_release</code> 同样使用原子方法将 locked 字段置为 0，从而实现锁的释放。</p>
<p><img src="https://906337931-files.gitbook.io/~/files/v0/b/gitbook-legacy-files/o/assets%2F-MHZoT2b_bcLghjAOPsJ%2F-MPS4AMuEHdeXFZVa2tv%2F-MPTQ6_2PmfELO2S40wq%2Fimage.png?alt=media&amp;token=d7b4b0e0-50cf-4fd8-80b9-00fbb94522a4" alt=""></p>
<h2 id="9-"><a class="anchor" href="#9-">#</a> 9 线程切换</h2>
<h3 id="91-"><a class="anchor" href="#91-">#</a> 9.1 线程概述</h3>
<h4 id="heading-24"><a class="anchor" href="#heading-24">#</a> 为何使用多线程</h4>
<ol>
<li>希望计算机具有分时性，在同一时间能够执行多个任务。</li>
<li>多线程有时能够合理组织程序，降低程序复杂度。</li>
<li>多线程可通过并行计算提高计算机性能。</li>
</ol>
<h4 id="heading-25"><a class="anchor" href="#heading-25">#</a> 线程的定义</h4>
<p>对同时多任务编程的抽象，可被认为是串行执行代码的单元。线程具有状态，因此我们可以随时保存其状态并暂停或恢复它。线程的状态包括：</p>
<ol>
<li>程序计数器（PC），表示当前线程执行的位置</li>
<li>保存变量的寄存器</li>
<li>程序的栈，记录了函数调用情况，同时反映当前线程的执行点</li>
</ol>
<h4 id="heading-26"><a class="anchor" href="#heading-26">#</a> 多线程并行</h4>
<p>多线程并行一般有两种策略：在每个CPU上运行一个线程，以及在一个CPU上运行多个线程。</p>
</article>
  </div>
</body>

</html>