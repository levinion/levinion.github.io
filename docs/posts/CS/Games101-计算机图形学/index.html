<!DOCTYPE html>
<html data-theme="dark">

<head>
  
<meta charset="UTF-8" />
<meta http-equiv="X-UA-Compatible" content="IE=edge" />
<meta name="viewport" content="width=device-width, initial-scale=1.0" />
<link rel="stylesheet" href="/assets/css/pico.css" />
<link rel="stylesheet" href="/assets/css/custom.css" />
<link rel="stylesheet"
      href="//cdnjs.cloudflare.com/ajax/libs/highlight.js/11.7.0/styles/atom-one-dark.min.css">
<script src="//cdnjs.cloudflare.com/ajax/libs/highlight.js/11.7.0/highlight.min.js"></script>
<script>
    hljs.initHighlightingOnLoad();
</script> 


  <style>
    article {
      background: rgb(28, 29, 33);
      max-width: 70%;
      text-align: left;
      margin: 0 auto;
      border-radius: 30px;
    }

    @media (max-width: 768px) {
      article {
        max-width: 90%;
      }

      h1 {
        font-size: large;
      }

      .date {
        font-size: medium;
      }

      p,
      li {
        font-size: 15px;
      }
    }

    p,
    li {
      font-size: 16.5px;
      line-height: 32px;
    }

    h1 {
      text-align: center;
      margin-bottom: 10px;
    }

    .meta p {
      text-align: center;
    }

    .date {
      text-align: center;
    }

    .toc {
      position: fixed;
      float: left;
      max-width: 50px;
      max-height: 50px;
      margin-top: 200px;
      text-align: center;
    }

    h2 {
      font-size: x-large;
      color: peru;
    }

    h3 {
      font-size: large;
      color: rgb(205, 158, 112);
    }

    h4 {
      font-size: medium;
      color: pink;
    }

    strong {
      color: rgb(182, 230, 240);
    }
  </style>
  <title>Games101-计算机图形学</title>
</head>

<body onselectstart="return false">
  
<nav>
  <a href="/" class="logo">Maruka's Blog</a>
  <div class="breadcrumb">
    <ul>
      <li>
        <a href="/posts">文章</a>
      </li>
      <li>
        <a href="/category">分类</a>
      </li>
      <li>
        <a href="/about">关于</a>
      </li>
    </ul>
  </div>
</nav>

  <div>
    <div class="meta">
      <h1>Games101-计算机图形学</h1>
      <p>2023-06-10 13:48:15</p>
    </div>
    <article><h2 id="heading"><a class="anchor" href="#heading">#</a> 计算机图形学</h2>
<h3 id="heading-1"><a class="anchor" href="#heading-1">#</a> 应用</h3>
<ul>
<li>电影、动画特效、设计（CAD）、CG（Computer Graphics）</li>
<li>可视化、虚拟现实、仿真/模拟</li>
<li>图形界面、字体&hellip;</li>
</ul>
<h3 id="heading-2"><a class="anchor" href="#heading-2">#</a> 挑战</h3>
<p>真实世界的理解、计算方法、显示方法</p>
<h3 id="heading-3"><a class="anchor" href="#heading-3">#</a> 内容</h3>
<p>数学理论、着色、形体、仿真动画，不包括OpenGL、DirectX、Vulcan等（图形学api）</p>
<ul>
<li>光栅化：广泛应用在实时图形学(&gt;30fps)</li>
<li>几何（曲线和曲面）</li>
<li>光线追踪：能达到较好的效果，但较慢</li>
<li>动画/模拟</li>
</ul>
<blockquote>
<p>图形学（模型渲染图片）!=计算机视觉（图片提取信息：分析、猜测、理解、推理）</p>
</blockquote>
<h3 id="heading-4"><a class="anchor" href="#heading-4">#</a> 作业</h3>
<p>不强制要求，意味着听听就行。每周具体作业代码不超过 20 行。最后有一个大作业。</p>
<h2 id="heading-5"><a class="anchor" href="#heading-5">#</a> 线性代数</h2>
<p>坐标、平移、旋转 ==&gt; 矩阵计算</p>
<h3 id="heading-6"><a class="anchor" href="#heading-6">#</a> 向量</h3>
<p><img src="https://www.zhihu.com/equation?tex=%5Cbbox%5Bwhite%5D%7B%5Cvec%7BAB%7D=%5Cvec%7BB%7D-%5Cvec%7BA%7D%7D" alt=""></p>
<ul>
<li>
<p>向量加法（三角形法则）<img src="https://www.zhihu.com/equation?tex=%5Cbbox%5Bwhite%5D%7B%5Cvec%7BAB%7D=%5Cvec%7BAO%7D%2B%5Cvec%7BOB%7D%7D" alt=""></p>
</li>
<li>
<p>向量点乘（Dot）: 表示方向性<img src="https://www.zhihu.com/equation?tex=%5Cbbox%5Bwhite%5D%7B%5Cvec%7Ba%7D%5Ccdot%5Cvec%7Bb%7D=%7C%5Cvec%7Ba%7D%7C%7C%5Cvec%7Bb%7D%7C%5Ccdot%5Ccos(%5Ctheta)%7D" alt=""></p>
</li>
<li>
<p>投影
b在a上的投影：<img src="https://www.zhihu.com/equation?tex=%5Cbbox%5Bwhite%5D%7Bk=%7C%5Cvec%7Bb%7D%7C%5Ccos%5Ctheta%7D" alt=""></p>
</li>
<li>
<p>叉乘（方向根据右手定则）：已知两个坐标系得到另一个坐标系<img src="https://www.zhihu.com/equation?tex=%5Cbbox%5Bwhite%5D%7B%7C%5Cvec%7Ba%7D%5Ctimes%5Cvec%7Bb%7D%7C=%7C%5Cvec%7Ba%7D%7C%7C%5Cvec%7Bb%7D%7C%5Csin%5Cphi%7D" alt=""></p>
</li>
</ul>
<h3 id="heading-7"><a class="anchor" href="#heading-7">#</a> 矩阵</h3>
<ul>
<li>矩阵乘法（矩阵X矩阵、矩阵X向量）</li>
<li>结合律、分配律、无交换律</li>
<li>单位矩阵</li>
<li>逆矩阵</li>
</ul>
<h2 id="heading-8"><a class="anchor" href="#heading-8">#</a> 变换</h2>
<p>变换即是对目标的每一个点进行变换，以得到整体的改变。复杂变换可由简单变换得到，和变换的顺序有关。</p>
<h3 id="heading-9"><a class="anchor" href="#heading-9">#</a> 二维变换</h3>
<h4 id="heading-10"><a class="anchor" href="#heading-10">#</a> 缩放变换</h4>
<p><img src="https://www.zhihu.com/equation?tex=%5Cbbox%5Bwhite%5D%7Bx%5E%7B'%7D=sx~~or~~y%5E%7B'%7D=sy%7D" alt=""></p>
<h4 id="heading-11"><a class="anchor" href="#heading-11">#</a> 反转</h4>
<p><img src="https://www.zhihu.com/equation?tex=%5Cbbox%5Bwhite%5D%7Bx%5E%7B'%7D=-x~~or~~y%5E%7B'%7D=-y%7D" alt=""></p>
<p><img src="https://www.zhihu.com/equation?tex=%5Cbbox%5Bwhite%5D%7B%5Cbegin%7Bbmatrix%7D%0Ax%5E%7B%27%7D+%5C%5C+y%5E%7B%27%7D%0A%5Cend%7Bbmatrix%7D%0A%3D%0A%5Cbegin%7Bbmatrix%7D%0A-1+%26+0+%5C%5C+0+%26+1+%0A%5Cend%7Bbmatrix%7D%0A%5Cbegin%7Bbmatrix%7D%0Ax+%5C%5C+y%0A%5Cend%7Bbmatrix%7D%0A%7D" alt=""></p>
<h4 id="heading-12"><a class="anchor" href="#heading-12">#</a> 切变</h4>
<p><img src="https://www.zhihu.com/equation?tex=%5Cbbox%5Bwhite%5D%7B%5Cbegin%7Bbmatrix%7D%0Ax%5E%7B%27%7D+%5C%5C+y%5E%7B%27%7D%0A%5Cend%7Bbmatrix%7D%0A%3D%0A%5Cbegin%7Bbmatrix%7D%0A1+%26+a+%5C%5C+0+%26+1+%0A%5Cend%7Bbmatrix%7D%0A%5Cbegin%7Bbmatrix%7D%0Ax+%5C%5C+y%0A%5Cend%7Bbmatrix%7D%0A%7D" alt=""></p>
<h4 id="heading-13"><a class="anchor" href="#heading-13">#</a> 旋转</h4>
<p><img src="https://www.zhihu.com/equation?tex=%5Cbbox%5Bwhite%5D%7BR_%5Ctheta%3D%5Cbegin%7Bbmatrix%7D%0A%5Ccos%5Ctheta+%26+-%5Csin%5Ctheta%5C%5C%0A%5Csin%5Ctheta+%26+%5Ccos%5Ctheta+%0A%5Cend%7Bbmatrix%7D%0A%7D" alt=""></p>
<h4 id="heading-14"><a class="anchor" href="#heading-14">#</a> 线性变换</h4>
<p><img src="https://www.zhihu.com/equation?tex=%5Cbbox%5Bwhite%5D%7B%5Cbegin%7Bbmatrix%7D%0Ax%5E%7B%27%7D%5C%5C+y%5E%7B%27%7D%0A%5Cend%7Bbmatrix%7D%0A%3D%0A%5Cbegin%7Bbmatrix%7D%0Aa%26b%5C%5C+c%26d%0A%5Cend%7Bbmatrix%7D%0A%5Cbegin%7Bbmatrix%7D%0Ax%5C%5C+y%0A%5Cend%7Bbmatrix%7D%7D" alt=""></p>
<p>即<img src="https://www.zhihu.com/equation?tex=%5Cbbox%5Bwhite%5D%7Bx%5E%7B%27%7D%3Dax%2Bby%7D" alt=""></p>
<p><img src="https://www.zhihu.com/equation?tex=%5Cbbox%5Bwhite%5D%7By%5E%7B%27%7D%3Dcx%2Bdy%7D" alt=""></p>
<p>即<img src="https://www.zhihu.com/equation?tex=%5Cbbox%5Bwhite%5D%7Bx%5E%7B%27%7D%3DMx%7D" alt=""></p>
<p>称为线性变换。以上均属于线性变换。</p>
<h4 id="heading-15"><a class="anchor" href="#heading-15">#</a> 平移</h4>
<p>平移是一种特殊的二维变换，它不属于线性变换，因为：<img src="https://www.zhihu.com/equation?tex=%5Cbbox%5Bwhite%5D%7B%0A%5Cbegin%7Bbmatrix%7D%0Ax%5E%7B%27%7D%5C%5C+y%5E%7B%27%7D%0A%5Cend%7Bbmatrix%7D%3D%0A%5Cbegin%7Bbmatrix%7D%0Aa+%26+b+%5C%5C+c%26d%0A%5Cend%7Bbmatrix%7D%0A%5Cbegin%7Bbmatrix%7D%0Ax+%5C%5C+y%0A%5Cend%7Bbmatrix%7D%0A%2B%0A%5Cbegin%7Bbmatrix%7D%0At_x+%5C%5C+t_y%0A%5Cend%7Bbmatrix%7D%7D" alt=""></p>
<p>为了解决其特殊性，引入齐次坐标。</p>
<h4 id="heading-16"><a class="anchor" href="#heading-16">#</a> 引入齐次坐标</h4>
<p>为二维的点或向量增加一个维度，得到仿射变换的通式。</p>
<p><img src="https://www.zhihu.com/equation?tex=%5Cbbox%5Bwhite%5D%7B%5Cbegin%7Bbmatrix%7D%0Ax%5E%7B%27%7D%5C%5C+y%5E%7B%27%7D+%5C%5C+w%5E%7B%27%7D%0A%5Cend%7Bbmatrix%7D%0A%3D%0A%5Cbegin%7Bbmatrix%7D%0A1%260%26t_x%5C%5C+0%261%26t_y%5C%5C+0%26+0+%261%0A%5Cend%7Bbmatrix%7D%0A%5Cbegin%7Bbmatrix%7D%0Ax%5C%5C+y%5C%5C+1%0A%5Cend%7Bbmatrix%7D%0A%3D%5Cbegin%7Bbmatrix%7D%0Ax%2Bt_x+%5C%5C+y%2Bt_y%5C%5C+1%0A%5Cend%7Bbmatrix%7D%7D" alt=""></p>
<p>w 为 0 或 1，以满足平移变换后的向量或点的不变性。其中 0 表示向量，1 表示点。</p>
<p>因此：</p>
<ul>
<li>点-点=向量</li>
<li>向量+-向量=向量</li>
<li>点+-向量=点</li>
<li>点+点=2？=&gt;点，若w!=0，w=w/w，x=x/w，其他同理</li>
</ul>
<p>代价即是引入了一个额外的坐标，但是可省略仿射变换，只保留左上角矩阵，因此代价不高。</p>
<p>另外，在三维空间中，用四个参数描述一个三维齐次坐标系下的点。</p>
<h4 id="heading-17"><a class="anchor" href="#heading-17">#</a> 变换的组合性</h4>
<p><img src="https://www.zhihu.com/equation?tex=%5Cbbox%5Bwhite%5D%7BR%3DA_1%2AA_2%2A...%2AS%7D" alt=""></p>
<p>复杂变换可由简单变换组合而成，其顺序相关，同时变换矩阵维数相同（3*3）</p>
<h3 id="heading-18"><a class="anchor" href="#heading-18">#</a> 三维变换</h3>
<p>同二维变换，用四个坐标描述一个三维坐标中的点：一个四维矩阵</p>
<h4 id="heading-19"><a class="anchor" href="#heading-19">#</a> 旋转</h4>
<p>有旋转矩阵：</p>
<p><img src="https://www.zhihu.com/equation?tex=%5Cbbox%5Bwhite%5D%7B%0AR_%7Bx%7D%28%5Calpha%29%3D%0A%5Cbegin%7Bbmatrix%7D%0A1%260%260%260+%5C%5C%0A0%26%5Ccos+%5Calpha+%26+-%5Csin+%5Calpha+%260+%5C%5C%0A0+%26%5Csin+%5Calpha+%26%5Ccos+%5Calpha+%260+%5C%5C%0A0%260%260%261%0A%5Cend%7Bbmatrix%7D%0A%7D" alt=""></p>
<p><img src="https://www.zhihu.com/equation?tex=%5Cbbox%5Bwhite%5D%7B%0AR_%7By%7D%28%5Calpha%29%3D%0A%5Cbegin%7Bbmatrix%7D%0A%5Ccos+%5Calpha%260%26%5Csin+%5Calpha%260+%5C%5C%0A0%261+%26+0+%260+%5C%5C%0A-+%5Csin+%5Calpha%260+%26%5Ccos+%5Calpha+%260+%5C%5C%0A0%260%260%261%0A%5Cend%7Bbmatrix%7D%0A%7D" alt=""></p>
<p><img src="https://www.zhihu.com/equation?tex=%5Cbbox%5Bwhite%5D%7B%0AR_%7Bz%7D%28%5Calpha%29%3D%0A%5Cbegin%7Bbmatrix%7D%0A%5Ccos+%5Calpha%26-%5Csin+%5Calpha%260+%260%5C%5C%0A%5Csin+%5Calpha%26%5Ccos+%5Calpha+%26+0+%260+%5C%5C%0A0+%260+%260%260+%5C%5C%0A0%260%260%261%0A%5Cend%7Bbmatrix%7D%0A%7D" alt=""></p>
<p>三维旋转可由三个独立二维旋转行为描述，用欧拉角描述，分为横滚角、俯仰角、航向角</p>
<p><img src="https://www.zhihu.com/equation?tex=%5Cbbox%5Bwhite%5D%7BR_%7Bxyz%7D%28%5Calpha%2C%5Cbeta%2C%5Cgamma%29%3DR_x%28%5Calpha%29R_y%28%5Cbeta%29R_z%28%5Cgamma%29%7D" alt=""></p>
<blockquote>
<p>罗德里格斯旋转公式：<img src="https://www.zhihu.com/equation?tex=%5Cbbox%5Bwhite%5D%7BR+%3D+I+%2B+%5Csin%5Ctheta+%2A+A+%2B+%281-%5Ccos%5Ctheta%29+%2A+A%5E2%7D" alt="">
可计算出任意轴和任意角度的旋转变换矩阵</p>
</blockquote>
<h3 id="mvp"><a class="anchor" href="#mvp">#</a> MVP变换</h3>
<p>M - Model 变换: 将物体从对象空间转换到世界空间。它包含物体的缩放、旋转和位置变换。</p>
<p>V - View 变换: 将世界空间转换到视图空间。它决定摄像机的位置和方向。</p>
<p>P - Projection 变换: 将视图空间转换到裁剪空间。它实现透视效果, 包含视锥体和视口的定义。</p>
<p>这三个变换的综合结果是将三维物体最终投影到二维屏幕上的效果。它们的作用顺序是: 物体空间 → 世界空间 → 视图空间 → 裁剪空间 → 屏幕空间。</p>
<h3 id="heading-20"><a class="anchor" href="#heading-20">#</a> 投影</h3>
<p>投影分为正交投影和透视投影，正交投影能够更好地反映比例，透视投影更加贴近真实。</p>
<p>方法是定义近和远两个平面，从一个平面投影向另一个平面。正交投影和透视投影的区别在于投影线是否平行，也就是投影面是否等大。</p>
<p>正交的计算方法形同平移，投影的坐标计算依赖于相似三角形。</p>
<p><img src="https://www.zhihu.com/equation?tex=%5Cbbox%5Bwhite%5D%7By%5E%7B%27%7D%3D%5Cfrac%7Bn%7D%7Bz%7Dy%7D" alt=""></p>
<p><img src="https://www.zhihu.com/equation?tex=%5Cbbox%5Bwhite%5D%7Bx%5E%7B%27%7D%3D%5Cfrac%7Bn%7D%7Bz%7Dx%7D" alt=""></p>
<p>n 和 z 分别是远平面和近平面到延长线和水平面交点的距离。</p>
<p>一个很好的资料是：<a href="https://zhuanlan.zhihu.com/p/448547679">（超详细！）计算机图形学 入门篇 2. 视图变换（Viewing Transformations）</a></p>
<h4 id="heading-21"><a class="anchor" href="#heading-21">#</a> 正交投影</h4>
<p>正交投影的工作是将空间的长方体移动到原点并压缩成一个正方体。</p>
<p>有</p>
<p><img src="https://www.zhihu.com/equation?tex=%5Cbbox%5Bwhite%5D%7B%0AM_%7Bortho%7D%3D%5Cbegin%7Bbmatrix%7D%0A%5Cfrac%7B2%7D%7Br-l%7D%260%260%260+%5C%5C%0A0+%26+%5Cfrac%7B2%7D%7Bt-b%7D+%260%260%5C%5C+%0A0%260%26+%5Cfrac%7B2%7D%7Bn-f%7D+%260+%5C%5C%0A0%260%260%261%0A%5Cend%7Bbmatrix%7D%0A%5Cbegin%7Bbmatrix%7D%0A1%260%260%26-+%5Cfrac%7Br%2Bl%7D%7B2%7D+%5C%5C%0A0%261%260%26-+%5Cfrac%7Bt%2Bb%7D%7B2%7D+%5C%5C%0A0%260%261%26-+%5Cfrac%7Bn%2Bf%7D%7B2%7D%5C%5C%0A0%260%260%261+%5C%5C%0A%5Cend%7Bbmatrix%7D%0A%7D" alt=""></p>
<p>其中，(l,r)(b,t)(f,n)定义一个长方体，代表左右、上下、前后。</p>
<h4 id="heading-22"><a class="anchor" href="#heading-22">#</a> 透视投影</h4>
<p>透视投影的工作是将远平面压缩成近平面等大，即将一个梯台变换为一个长方体。之后再进行正交投影就称为透视变换。</p>
<p>有</p>
<p><img src="https://www.zhihu.com/equation?tex=%5Cbbox%5Bwhite%5D%7B%0AM_%7Bpersp%7D%3D%5Cbegin%7Bbmatrix%7D%0An%260%260%260+%5C%5C%0A0%26n%260%260+%5C%5C%0A0%260%26n%2Bf%26-fn+%5C%5C%0A0%260%261%260%0A%5Cend%7Bbmatrix%7D%0A%7D" alt=""></p>
<h4 id="heading-23"><a class="anchor" href="#heading-23">#</a> 总变换矩阵</h4>
<p>先后进行透视投影和正交投影，得到总变换矩阵：</p>
<p><img src="https://www.zhihu.com/equation?tex=%5Cbbox%5Bwhite%5D%7B%0AM_%7Bper%7D%3DM_%7Bortho%7DM_%7Bpersp%7D%3D%5Cbegin%7Bbmatrix%7D%0A%5Cfrac%7B2n%7D%7Br-l%7D%260%26+%5Cfrac%7Bl%2Br%7D%7Bl-r%7D%260+%5C%5C%0A0%26+%5Cfrac%7B2n%7D%7Bt-b%7D+%26+%5Cfrac%7Bb%2Bt%7D%7Bb-t%7D%260+%5C%5C%0A0%260%26+%5Cfrac%7Bf%2Bn%7D%7Bn-f%7D+%26+%5Cfrac%7B2fn%7D%7Bf-n%7D+%5C%5C%0A0%260%261%260+%5C%5C%0A%5Cend%7Bbmatrix%7D%0A%7D" alt=""></p>
<h4 id="heading-24"><a class="anchor" href="#heading-24">#</a> 另一种表述</h4>
<p>有时我们偏向使用eye_fovy（垂向视角）和aspect_ratio（宽高比进行表述）。其中，</p>
<p><img src="https://www.zhihu.com/equation?tex=%5Cbbox%5Bwhite%5D%7B%5Cfrac%7Bt%7D%7Bn%7D%3D%5Ctan%7B%5Cfrac%7Bfovy%7D%7B2%7D%7D%7D" alt=""></p>
<p><img src="https://www.zhihu.com/equation?tex=%5Cbbox%5Bwhite%5D%7Baspect%3D%5Cfrac%7Bt%7D%7Br%7D%7D" alt=""></p>
<h3 id="pa0"><a class="anchor" href="#pa0">#</a> PA0</h3>
<p>P点坐标（2，1），逆时针旋转45度，再平移（2，1），利用齐次坐标计算变换后的坐标。</p>
<pre><code class="language-cpp">#include &lt;cmath&gt;
#include &lt;eigen3/Eigen/Core&gt;
#include &lt;eigen3/Eigen/Dense&gt;
#include &lt;iostream&gt;
#include &lt;math.h&gt;
#include &lt;numbers&gt;
#include &lt;ostream&gt;

using namespace std::numbers;

int main() {
  // 定义齐次坐标3维向量
  auto p = Eigen::Vector3f{2, 1, 1};
  //定义变换矩阵(3D)
  Eigen::Matrix3f r;
  r &lt;&lt; cos(pi / 4), -sin(pi / 4), 2, sin(pi / 4), cos(pi / 4), 1, 0, 0, 1;
  std::cout &lt;&lt; &quot;Print R: &quot; &lt;&lt; std::endl;
  std::cout &lt;&lt; r &lt;&lt; std::endl;
  //计算变换后坐标
  p = r * p;
  //抛弃第3维，保留二维结果
  std::cout &lt;&lt; &quot;result print here&quot; &lt;&lt; std::endl;
  std::cout &lt;&lt; &quot;(&quot; &lt;&lt; p.x() &lt;&lt; &quot;,&quot; &lt;&lt; p.y() &lt;&lt; &quot;)&quot; &lt;&lt; std::endl;
}
</code></pre>
<p>输出如下：</p>
<pre><code class="language-sh">Print R: 
 0.707107 -0.707107         2
 0.707107  0.707107         1
        0         0         1
result print here
(2.70711,3.12132)
</code></pre>
<p>PA0 很容易，这里借 PA0 大致说一下环境配置问题：</p>
<ol>
<li>需要 eigen 和 opencv 两个库，推荐使用系统的包管理器下载: <code>paru -S eigen opencv</code></li>
<li>opencv 可能由于路径问题（多出一个 opencv4 目录）无法找到库，建立一个软链接：<code>sudo ln -s /usr/include/opencv4/opencv2 /usr/include/</code></li>
<li>推荐使用 xmake 管理项目（当然你用 vs 或 cmake 也行），需要在 xmake. lua 中添加依赖 <code>set_requires(&quot;opencv&quot;)</code> 以及 <code>set_packages(&quot;opencv&quot;)</code></li>
<li>然后使用xmake编译和运行</li>
</ol>
<h3 id="pa1"><a class="anchor" href="#pa1">#</a> PA1</h3>
<p>填写一个旋转矩阵和一个透视投影矩阵。给定三维下三个点 v0 (2.0, 0.0, −2.0), v1 (0.0, 2.0, −2.0), v2 (−2.0, 0.0, −2.0), 你需要将这三个点的坐标变换为屏幕坐标并在屏幕上绘制出对应的线框三角形。</p>
<blockquote>
<p>PS: 大概是我太弱，PA1 做得异常艰难，好不容易才弄懂。重要的大概就是几个变换矩阵，知道怎么推出来直接拿来用就好。再次鸣谢 <a href="https://zhuanlan.zhihu.com/p/448547679">keanu大佬的笔记</a>！</p>
</blockquote>
<p>模型变换代码如下：</p>
<pre><code class="language-cpp">Eigen::Matrix4f get_model_matrix(float rotation_angle) {
  // 创建一个单位阵
  Eigen::Matrix4f model = Eigen::Matrix4f::Identity();
  Eigen::Matrix4f rotation;

  // 角度制转弧度制
  rotation_angle = rotation_angle * std::numbers::pi / 180;
  // 返回一个旋转矩阵，同齐次坐标的矩阵相乘
  rotation &lt;&lt; cos(rotation_angle), -sin(rotation_angle), 0, 0,
      sin(rotation_angle), cos(rotation_angle), 0, 0, 0, 0, 1, 0, 0, 0, 0, 1;

  model = rotation * model;
  return model;
}
</code></pre>
<p>投影变换代码如下：</p>
<pre><code class="language-cpp">// 给出的参数包括眼角和宽高比，近平面和远平面
Eigen::Matrix4f get_projection_matrix(float eye_fov, float aspect_ratio,
                                      float zNear, float zFar) {

  Eigen::Matrix4f projection = Eigen::Matrix4f::Identity();

  // 角度制转弧度制
  eye_fov = eye_fov * std::numbers::pi / 180;

  // 倒三角问题
  // 注意，此处的zNear和zFar传入的均是绝对值，表示相对屏幕的距离。需要转化为坐标
  // 由于看向的是-z方向，最后的变换矩阵w的1也需要改为-1

  float n = -zNear;
  float f = -zFar;
  float t = n * tan(eye_fov / 2);
  float b = -t;
  float r = t / aspect_ratio;
  float l = -r;

  Eigen::Matrix4f per;
  per &lt;&lt; 2 * n / (r - l), 0, (l + r) / (l - r), 0, 0, 2 * n / (t - b),
      (b + t) / (b - t), 0, 0, 0, (f + n) / (n - f), 2 * f * n / (f - n), 0, 0,
      -1, 0;
  projection = per * projection;
  return projection;
}
</code></pre>
<h2 id="heading-25"><a class="anchor" href="#heading-25">#</a> 光栅化</h2>
<h3 id="heading-26"><a class="anchor" href="#heading-26">#</a> 一些定义</h3>
<h4 id="heading-27"><a class="anchor" href="#heading-27">#</a> 屏幕</h4>
<p>二维数组，表示屏幕大小（像素多少），称为分辨率；典型的光栅（Raster，德语的 Screen）成像设备。</p>
<h4 id="pixel"><a class="anchor" href="#pixel">#</a> 像素（Pixel）</h4>
<p>带有颜色的方块，屏幕的最小组成单位；rgb 的组合；内部不会发生颜色变化；</p>
<h4 id="heading-28"><a class="anchor" href="#heading-28">#</a> 屏幕空间</h4>
<p>屏幕坐标系，将像素的坐标用 (x, y) 表示；(2, 1) 表示左 3 下 2 的像素（下标从 0 开始）。</p>
<h4 id="rasteriza"><a class="anchor" href="#rasteriza">#</a> 光栅化（Rasteriza）</h4>
<p>将多边形绘画在屏幕空间上。</p>
<h3 id="heading-29"><a class="anchor" href="#heading-29">#</a> 光栅成像设备</h3>
<h4 id="crt-"><a class="anchor" href="#crt-">#</a> CRT 显示器</h4>
<p>阴极射线管的缩写，电子偏移并打在屏幕上成像。利用隔行扫描技术，会造成画面撕裂，产生鬼影。</p>
<h4 id="lcd-"><a class="anchor" href="#lcd-">#</a> LCD 显示器</h4>
<p>液晶显示器。通过液晶扭曲调整光的方向。</p>
<h4 id="led-"><a class="anchor" href="#led-">#</a> LED 显示器</h4>
<p>LED 即发光二极管，与以上显示设备原理不同。使用小的发光二极管分别成像。</p>
<h3 id="heading-30"><a class="anchor" href="#heading-30">#</a> 几何基础</h3>
<p>三角形：多边形的基础，几乎所有实体都可以拆解成三角形；可以方便地利用叉积分别内外&hellip;</p>
<h3 id="heading-31"><a class="anchor" href="#heading-31">#</a> 采样</h3>
<p>函数的离散化。基本的采样过程是判断一个像素的中心是否在三角形内。在边界上，一些软件（OpenGL 等）规定上边和左边上的点在三角形内，下边和右边上的点在三角形外。</p>
<h4 id="heading-32"><a class="anchor" href="#heading-32">#</a> 采样理论</h4>
<h5 id="heading-33"><a class="anchor" href="#heading-33">#</a> 走样</h5>
<p>Artifacts，即采样产生的瑕疵、不准确和错误。常见的 artifacts 包括锯齿、摩尔纹、车轮效应，其中前两个是空间采样问题，后者是时间采样问题。<strong>走样的原因是信号变化太快导致采样无法跟上（采样频率过低）。</strong></p>
<p>我们使用频率定义信号的变化速度，频率的倒数称为周期。</p>
<p>使用傅立叶级数展开可以将任何函数展开为一系列正弦/余弦函数和常数项的和。这里引出采样频率的概念，若采样频率太低，导致无法区分两个不同的函数，就导致走样。</p>
<h5 id="heading-34"><a class="anchor" href="#heading-34">#</a> 滤波</h5>
<p>一个行之有效的反走样手段是 pre-fliter，即提前模糊处理，也称为<strong>滤波</strong>，然后进行采样。</p>
<p>傅里叶变换使时域转换为频域。中间表示低频信息（模糊图像），四周表示高频信息（表示边界）。</p>
<p>筛选信息的工具是滤波器。</p>
<h5 id="heading-35"><a class="anchor" href="#heading-35">#</a> 卷积</h5>
<p>滤波等同于平均，等同于卷积操作。</p>
<p>卷积操作比较简单，滤波器在信号窗口上滑动，与对应位置求点积，记录中心位置结果。最终结果是一个像素自身及其周围像素的平均，从而达到模糊效果。时域卷积等于频域乘积（也就是低通滤波效果）。</p>
<p>一些结论：</p>
<ol>
<li>卷积核之和为 1</li>
<li>卷积和越大越模糊</li>
</ol>
<h5 id="heading-36"><a class="anchor" href="#heading-36">#</a> 采样</h5>
<p>在时域上，相当于，原始连续函数乘以多个冲击函数（只在固定位置上有值，其他位置无值），从而得到一系列离散的点。</p>
<p>在频域上，相当于这两个函数的卷积。采样相当于重复原始频谱的过程。</p>
<p>采样越稀疏，在频域上越密集，频谱在搬移的情况下发生混叠，此即发生走样的原因。</p>
<h4 id="heading-37"><a class="anchor" href="#heading-37">#</a> 反走样</h4>
<ol>
<li>增加采样率</li>
<li>反走样：先模糊后采样，即先做高通滤波再采样（在频域上减少信号频谱宽度），方法是使用低通滤波器进行卷积操作</li>
</ol>
<p>实际工业抗锯齿使用 MSAA 方法，得到抗锯齿效果。分割像素，得到 n*n 个点。得到每个像素的覆盖率。缺点是增大了计算量。另外还有 FXAA（快速近似抗锯齿，原理是图像匹配抗锯齿）、TAA（时间抗锯齿，复用上一帧）方法。</p>
<p>另外一个概念是超分辨率。提高分辨率，实际还是为了解决样本不足的问题。常用 DLSS，用深度学习进行超采样。</p>
<h3 id="heading-38"><a class="anchor" href="#heading-38">#</a> 可见性</h3>
<p>可见性问题即解决多个物体遮挡的问题</p>
<h4 id="heading-39"><a class="anchor" href="#heading-39">#</a> 画家算法</h4>
<p>依序从远到近作画，近处的物体覆盖远处的物体，从而解决遮挡问题。</p>
<p>但是无法处理存在互相遮挡关系的物体之间的深度关系，故不采用。</p>
<h4 id="z-buffer"><a class="anchor" href="#z-buffer">#</a> Z-Buffer</h4>
<p>即深度缓存。通过遍历每个几何体，记录其每个像素的深度，在 buffer 中保留最浅深度。算法复杂度为 O (n)。伪代码如下，其中frameBuffer保存颜色信息，zbuffer保存深度信息。</p>
<pre><code class="language-cpp">//初始化深度为正无穷
zbuffer[x,y]=infinity
for each Triangle T{
  for each sample (x,y,z) in T{
    //保留最小深度的深度和颜色信息作为该像素的参数
    if z&lt;zbuffer[x,y]{
      frameBuffer[x,y]=rgb
      zbuffer[x,y]=z
    }
  }
}
</code></pre>
<p>算法假设不存在在同一像素上同深度的物体。</p>
<h3 id="pa2"><a class="anchor" href="#pa2">#</a> PA2</h3>
<ol>
<li>实现三角形栅格化算法；实现zbuffer算法</li>
</ol>
<pre><code class="language-cpp">// Screen space rasterization
void rst::rasterizer::rasterize_triangle(const Triangle &amp;t) {
  auto v = t.toVector4();

  //   获取盒子的边界
  float left = width;
  float right = 0;
  float top = 0;
  float bottom = height;

  for (auto i : v) {
    left = std::min(i.x(), left);
    right = std::max(i.x(), right);
    top = std::max(i.y(), top);
    bottom = std::min(i.y(), bottom);
  }

  // 遍历盒子里面的每一个像素；
  // 此处因为一开始用auto，被识别成float，de了半天bug orz;
  for (int y = bottom; y &lt; right; y++)
    for (int x = left; x &lt; right; x++) {
      // 判断像素中心是否在物体中
      if (insideTriangle(x + 0.5, y + 0.5, t.v)) {
        // 被提供的代码，用来获得深度
        auto [alpha, beta, gamma] = computeBarycentric2D(x, y, t.v);
        float w_reciprocal =
            1.0 / (alpha / v[0].w() + beta / v[1].w() + gamma / v[2].w());
        float z_interpolated = alpha * v[0].z() / v[0].w() +
                               beta * v[1].z() / v[1].w() +
                               gamma * v[2].z() / v[2].w();
        z_interpolated *= w_reciprocal;
        int index = get_index(x, y);
        // 若是，记录深度和颜色
        if (z_interpolated &lt; depth_buf[index]) {
          Vector3f p;
          p &lt;&lt; x, y, z_interpolated;
          set_pixel(p, t.getColor());
          depth_buf[index] = z_interpolated;
        }
      }
    }
}
</code></pre>
<ol start="2">
<li>测试点是否在三角形内</li>
</ol>
<pre><code class="language-cpp">// 用以判断点是否在三角形内
static bool insideTriangle(int x, int y, const Vector3f *_v) {
  // _v是数组，包含三个点，命名为A,B,C
  auto a = _v[0];
  auto b = _v[1];
  auto c = _v[2];
  // 定义该点为P
  Vector3f p;
  p &lt;&lt; x, y, 1;
  // 计算(ab,ap),(bc,bp),(ca,cp)的叉乘，判断z符号是否相同
  auto v1 = (b - a).cross(p - a).z();
  auto v2 = (c - b).cross(p - b).z();
  auto v3 = (a - c).cross(p - c).z();
  return (v1 &gt; 0 &amp;&amp; v2 &gt; 0 &amp;&amp; v3 &gt; 0) || (v1 &lt; 0 &amp;&amp; v2 &lt; 0 &amp;&amp; v3 &lt; 0);
}
</code></pre>
<ol start="3">
<li>映射变换继承 PA1</li>
</ol>
<h2 id="heading-40"><a class="anchor" href="#heading-40">#</a> 着色</h2>
<h3 id="heading-41"><a class="anchor" href="#heading-41">#</a> 定义</h3>
<p>Shading，引入颜色和明暗。在图形学上指材质作用于物体。</p>
<h3 id="blinn-phong-"><a class="anchor" href="#blinn-phong-">#</a> Blinn-Phong 反射模型</h3>
<p>根据明暗不同可将物体分为三个区块，分别是高光、漫反射和环境光照。注意，该反射模型只是一个经验公式。</p>
<h4 id="heading-42"><a class="anchor" href="#heading-42">#</a> 漫反射</h4>
<p>符合 Lambert&rsquo;s 余弦定律所表明的经验公式。其内容是：物体所吸收的光照与光线方向和物体表面法线之间夹角的余弦成正比。</p>
<p>有公式：</p>
<p><img src="https://www.zhihu.com/equation?tex=%5Cbbox%5Bwhite%5D%7B%0AL_%7Bd%7D%3Dk_%7Bd%7D%5Cleft%28+%5Cfrac%7BI%7D%7Br%5E2%7D+%5Cright%29max%280%2C%5Cvec%7Bn%7D%5Ccdot%7B%5Cvec%7Bl%7D%7D%29%0A%7D" alt=""></p>
<p>其中，Ld 是漫反射光照强度，kd 是物体颜色（三通道的 rgb 值），第二项指示到达物体的光的强度，第三项即余弦值（且不为负，因为没有意义），指示物体接收到的光的强度。</p>
<p>漫反射的特点在于和观测方向无关，因为它均匀反射到各个方向。</p>
<h4 id="heading-43"><a class="anchor" href="#heading-43">#</a> 高光</h4>
<p>观察方向与镜面反射方向足够接近时能够看到高光，或者说，法线方向与半程向量方向接近。半程向量即视线向量和光照向量的平均。</p>
<p><img src="https://www.zhihu.com/equation?tex=%5Cbbox%5Bwhite%5D%7B%0A%5Cvec%7Bh%7D%3Dbisector%28%5Cvec%7Bv%7D%2C%5Cvec%7Bl%7D%29%0A%7D" alt=""></p>
<p><img src="https://www.zhihu.com/equation?tex=%5Cbbox%5Bwhite%5D%7B%0AL_%7Bs%7D%3Dk_%7Bs%7D%5Cleft%28+%5Cfrac%7Bl%7D%7Br%5E2%7D+%5Cright%29max%280%2C%5Cvec%7Bn%7D%5Ccdot%7B%5Cvec%7Bh%7D%7D%29%5Ep%0A%7D" alt=""></p>
<p>其中，ks 是镜面反射系数。p 值通常取 100-200，p 值越大则高光区越小。</p>
<h4 id="heading-44"><a class="anchor" href="#heading-44">#</a> 环境光照</h4>
<p>环境光照来自四周，与观测方向、光照方向无关，因此可被认为是常数，有经验公式：</p>
<p><img src="https://www.zhihu.com/equation?tex=%5Cbbox%5Bwhite%5D%7B%0AL_%7Ba%7D%3Dk_%7Ba%7DI_%7Ba%7D%0A%7D" alt=""></p>
<p>ka 是环境光照系数。</p>
<h4 id="heading-45"><a class="anchor" href="#heading-45">#</a> 着色模型</h4>
<p><img src="https://www.zhihu.com/equation?tex=%5Cbbox%5Bwhite%5D%7B%0AL%3DL_%7Bd%7D%2BL_%7Bs%7D%2BL_%7Ba%7D%3Dk_%7Bd%7D%5Cleft%28+%5Cfrac%7BI%7D%7Br%5E2%7D+%5Cright%29max%280%2C%5Cvec%7Bn%7D%5Ccdot%7B%5Cvec%7Bl%7D%7D%29%2Bk_%7Bs%7D%5Cleft%28+%5Cfrac%7Bl%7D%7Br%5E2%7D+%5Cright%29max%280%2C%5Cvec%7Bn%7D%5Ccdot%7B%5Cvec%7Bh%7D%7D%29%5Ep%2Bk_%7Ba%7DI_%7Ba%7D%0A%7D" alt=""></p>
<h3 id="heading-46"><a class="anchor" href="#heading-46">#</a> 着色方式</h3>
<ol>
<li>Flat shading/平滑着色：对三角形求法线，内部无颜色过渡</li>
<li>Gouraud shading：逐顶点着色，利用插值，着色效果较好</li>
<li>Phong shading：逐像素着色，利用插值，着色效果最好</li>
</ol>
<p>着色频率取决于具体模型的复杂度，当面过于密集可能 flat shading 效果会更好。</p>
<h3 id="heading-47"><a class="anchor" href="#heading-47">#</a> 图形/实时渲染管线</h3>
<ol>
<li>顶点处理：空间上的点</li>
<li>变换：形成三角形</li>
<li>光栅化：采样和深度测试</li>
<li>着色</li>
</ol>
<h3 id="heading-48"><a class="anchor" href="#heading-48">#</a> 着色编程</h3>
<p>只需针对一个顶点或像素进行着色，称为顶点着色器或片段/像素着色器。</p>
<p>下面是一段 openGL GLSL 着色器例程：</p>
<pre><code class="language-c">uniform sampler2D myTexture;
uniform vec3 lightDir;
varying vec2 uv;
//插值得到的顶点法线
varying vec3 norm;

void diffuseShader(){
  vec3 kd;
  // 物体颜色
  kd = texture2d(myTexture,uv);
  // 着色模型，其中clamp将值限制在0-1
  kd *= clamp(dot(-lightDir,norm), 0, 0, 1, 0);
  // 输出片段颜色
  gl_FragColor = vec4(kd,1,0);
}

</code></pre>
<h4 id="-api"><a class="anchor" href="#-api">#</a> 一些 API</h4>
<p>shadertoy、openGL、directX</p>
<h4 id="heading-49"><a class="anchor" href="#heading-49">#</a> 硬件实现</h4>
<p>GPUs。独立显卡和图形显卡。</p>
<p>GPU 核心数量等于可并行的数量。其并行度高，适合做图形学（简单、相似）计算。</p>
<h3 id="heading-50"><a class="anchor" href="#heading-50">#</a> 纹理映射</h3>
<p>纹理（texture）即一张图片，将这张图片蒙罩在物体表面即称为纹理。纹理和物体存在一一对应关系。映射方法是光栅和纹理坐标的对应。</p>
<p>纹理坐标系为 (u, v)，定义域为 (0, 1)。</p>
<h3 id="heading-51"><a class="anchor" href="#heading-51">#</a> 插值</h3>
<h4 id="heading-52"><a class="anchor" href="#heading-52">#</a> 为什么要插值</h4>
<p>为了得到颜色的平滑过渡</p>
<h4 id="heading-53"><a class="anchor" href="#heading-53">#</a> 重心坐标</h4>
<p><img src="https://www.zhihu.com/equation?tex=%5Cbbox%5Bwhite%5D%7B%0A%28x%2C+y%29%3D%5Calpha+A%2B%5Cbeta+B%2B%5Cgamma+C%0A%7D" alt=""></p>
<p><img src="https://www.zhihu.com/equation?tex=%5Cbbox%5Bwhite%5D%7B%0A%5Calpha%2B%5Cbeta%2B%5Cgamma%3D1%0A%7D" alt=""></p>
<p><img src="https://www.zhihu.com/equation?tex=%5Cbbox%5Bwhite%5D%7B%0A%5Calpha%5Cgeq+0+%5Cquad+%5Cbeta%5Cgeq+0+%5Cquad+%5Cgamma%5Cgeq+0+%0A%7D" alt=""></p>
<p>由此，得到：</p>
<p><img src="https://www.zhihu.com/equation?tex=%5Cbbox%5Bwhite%5D%7B%0AV%3D%5Calpha+V_%7BA%7D%2B%5Cbeta+V_%7BB%7D%2B%5Cgamma+V_%7BC%7D%0A%7D" alt=""></p>
<p>其中，V_A, V_B, V_C 可以是位置、纹理、颜色、深度等</p>
<blockquote>
<p>重心坐标在投影过程中会发生变化，因此应对三维属性在三维空间中做插值</p>
</blockquote>
<h3 id="heading-54"><a class="anchor" href="#heading-54">#</a> 纹理范围问题</h3>
<h4 id="heading-55"><a class="anchor" href="#heading-55">#</a> 纹理过小</h4>
<p>当纹理分辨率过低，屏幕像素映射到一个非整数纹理坐标，此时需应用双线性插值。</p>
<p>线性插值即在两个像素之间按比例进行插值，双线性插值即取周围邻近的四个像素按垂直和水平两个方向进行线性插值。</p>
<h4 id="heading-56"><a class="anchor" href="#heading-56">#</a> 纹理过大</h4>
<p>会产生走样问题，近处产生锯齿，远处产生摩尔纹。</p>
<h4 id="mipmap"><a class="anchor" href="#mipmap">#</a> Mipmap</h4>
<p>纹理大小的通用解决方法。生成一系列原图的缩放图，原图称为第一层，其他层较上层分辨率缩小一半。需要的额外存储空间仅为原图的三分之一。</p>
<p>对区域在纹理上投影的像素近似为一个正方形，令 L 为该正方形边长。则 Mipmap 层数为：</p>
<p><img src="https://www.zhihu.com/equation?tex=%5Cbbox%5Bwhite%5D%7B%0AD%3D%5Clog_%7B2%7D%7BL%7D%0A%7D" alt=""></p>
<p>由于 Mipmap 是离散函数，会在边界产生不连续，因此需要在层与层之间再进行一次插值，配合水平和垂直的插值，称为三线性插值。</p>
<p>三线性插值在实时渲染中应用广泛，过渡连续，开销小。</p>
<p>但是三线性插值会产生 OverBlur 现象（远处模糊）。原因在与Mipmap使用正方形进行查询，解决方法有各向异性过滤（对应矩形区域查询有更好的效果，开销较高，是原图的三倍。对显存要求高），EWA过滤（使用圆形多次查询，效果好但代价高）</p>
<h3 id="pa3"><a class="anchor" href="#pa3">#</a> PA3</h3>
<p>PA3 主要包括以上章节的全部内容，难度稍高。其中 bump 和 displacement 着色器的实现有些超纲，故暂先不放出（可能留待后面补全）</p>
<h4 id="heading-57"><a class="anchor" href="#heading-57">#</a> 参数插值</h4>
<p>第一部分投影变换与作业一、二一致，故不再说了。参数插值部分代码如下：</p>
<pre><code class="language-cpp">// Screen space rasterization
void rst::rasterizer::rasterize_triangle(
    const Triangle &amp;t, const std::array&lt;Eigen::Vector3f, 3&gt; &amp;view_pos) {

  auto v = t.toVector4();
  int left = INT_MAX;
  int right = INT_MIN;
  int top = INT_MIN;
  int bottom = INT_MAX;
  for (auto p : v) {
    if (p.x() &lt; left)
      left = p.x();
    if (p.x() &gt; right)
      right = p.x();
    if (p.y() &lt; bottom)
      bottom = p.y();
    if (p.y() &gt; top)
      top = p.y();
  }
  for (auto x = left; x &lt;= right; x++)
    for (auto y = bottom; y &lt;= top; y++) {
      if (insideTriangle(x + 0.5, y + 0.5, t.v)) {
        // 得到重心坐标
        auto abg = computeBarycentric2D(x + 0.5, y + 0.5, t.v);
        // 使用get提取tuple中的元素
        auto alpha = std::get&lt;0&gt;(abg);
        auto beta = std::get&lt;1&gt;(abg);
        auto gamma = std::get&lt;2&gt;(abg);
        // 利用给出的公式计算zp
        //    * v[i].w() is the vertex view space depth value z.
        //    * Z is interpolated view space depth for the current pixel
        //    * zp is depth between zNear and zFar, used for z-buffer
        float Z = 1.0 / (alpha / v[0].w() + beta / v[1].w() + gamma / v[2].w());
        float zp = alpha * v[0].z() / v[0].w() + beta * v[1].z() / v[1].w() +
                   gamma * v[2].z() / v[2].w();
        zp *= Z;
        auto index = get_index(x, y);
        if (zp &lt; depth_buf[index]) {
          // 颜色插值
          auto interpolated_color = interpolate(alpha, beta, gamma, t.color[0],
                                                t.color[1], t.color[2], 1);
          // 法向量插值
          auto interpolated_normal = interpolate(
              alpha, beta, gamma, t.normal[0], t.normal[1], t.normal[2], 1);
          // 纹理插值
          auto interpolated_texcoords =
              interpolate(alpha, beta, gamma, t.tex_coords[0], t.tex_coords[1],
                          t.tex_coords[2], 1);
          // 内部点位置插值
          auto interpolated_shadingcoords = interpolate(
              alpha, beta, gamma, view_pos[0], view_pos[1], view_pos[2], 1);

          fragment_shader_payload payload(
              interpolated_color, interpolated_normal.normalized(),
              interpolated_texcoords, texture ? &amp;*texture : nullptr);
          payload.view_pos = interpolated_shadingcoords;
          auto pixel_color = fragment_shader(payload);
          set_pixel({x, y}, pixel_color);
          depth_buf[index] = zp;
        }
      }
    }
}
</code></pre>
<h4 id="phong-"><a class="anchor" href="#phong-">#</a> Phong 着色器</h4>
<pre><code class="language-cpp">Eigen::Vector3f phong_fragment_shader(const fragment_shader_payload &amp;payload) {
  // 漫反射系数
  Eigen::Vector3f ka = Eigen::Vector3f(0.005, 0.005, 0.005);
  // 颜色系数
  Eigen::Vector3f kd = payload.color;
  // 高光系数
  Eigen::Vector3f ks = Eigen::Vector3f(0.7937, 0.7937, 0.7937);

  auto l1 = light\{\{20, 20, 20}, {500, 500, 500\}\};
  auto l2 = light\{\{-20, 20, 0}, {500, 500, 500\}\};

  std::vector&lt;light&gt; lights = {l1, l2};
  Eigen::Vector3f amb_light_intensity{10, 10, 10};
  Eigen::Vector3f eye_pos{0, 0, 10};

  float p = 150;

  Eigen::Vector3f color = payload.color;
  Eigen::Vector3f point = payload.view_pos;
  Eigen::Vector3f normal = payload.normal;

  Eigen::Vector3f result_color = {0, 0, 0};
  for (auto &amp;light : lights) {
    // 出射光方向
    auto v = eye_pos - point;
    // 入射光方向
    auto l = light.position - point;
    // 半程向量
    auto h = (l + v).normalized();
    // r^2
    auto r2 = l.dot(l);
    auto Ld = kd.cwiseProduct(light.intensity / r2) *
              std::max(.0f, normal.normalized().dot(l.normalized()));
    auto Ls = ks.cwiseProduct(light.intensity / r2) *
              pow(std::max(.0f, normal.normalized().dot(h.normalized())), p);
    auto La = ka.cwiseProduct(amb_light_intensity);
    result_color += Ld + Ls + La;
  }

  return result_color * 255.f;
}
</code></pre>
<h4 id="heading-58"><a class="anchor" href="#heading-58">#</a> 纹理贴图</h4>
<pre><code class="language-cpp">Eigen::Vector3f
texture_fragment_shader(const fragment_shader_payload &amp;payload) {
  Eigen::Vector3f return_color = {0, 0, 0};
  if (payload.texture) {
    //其他部分代码基本和Phong相同，只是多了获取纹理颜色的这部分
    return_color = payload.texture-&gt;getColor(payload.tex_coords.x(),
                                             payload.tex_coords.y());
  }
  Eigen::Vector3f texture_color;
  texture_color &lt;&lt; return_color.x(), return_color.y(), return_color.z();

//...

</code></pre>
<h3 id="bump-textures"><a class="anchor" href="#bump-textures">#</a> 凹凸贴图（Bump Textures）</h3>
<p>凹凸贴图上一点 P 的切线为 (1, d_p)，其中 dp 为 u 变化一个单位，v 变化的值：</p>
<p><img src="https://www.zhihu.com/equation?tex=%5Cbbox%5Bwhite%5D%7B%0Ad_%7Bp%7D%3Dc%2A%28h_%7Bp%2B1%7D-h_%7Bp%7D%29%0A%7D" alt=""></p>
<p>则其法线为：</p>
<p><img src="https://www.zhihu.com/equation?tex=%5Cbbox%5Bwhite%5D%7B%0A%28-d_%7Bp%7D%5C+%2C%5C+1%29.normalized%28%29%0A%7D" alt=""></p>
<p>在三维中：</p>
<p><img src="https://www.zhihu.com/equation?tex=%5Cbbox%5Bwhite%5D%7B%0An%3D%28++-%5Cfrac%7Bd_%7Bp%7D%7D%7Bd_%7Bu%7D%7D%2C%5C++-%5Cfrac%7Bd_%7Bp%7D%7D%7Bd_%7Bv%7D%7D%2C%5C+1%29.normalized%28%29%0A%7D" alt=""></p>
<h3 id="displacement-textures"><a class="anchor" href="#displacement-textures">#</a> 位移贴图（Displacement Textures）</h3>
<p>和凹凸贴图的区别在于，凹凸贴图并没有改变顶点的位置，而位移贴图则改变了，因此效果较好，但更加消耗性能。</p>
<h3 id="heading-59"><a class="anchor" href="#heading-59">#</a> 纹理的其他应用</h3>
<ol>
<li>噪声：可通过噪声函数实现裂缝、大理石之类的纹路。</li>
<li>存储信息：记录已经计算好的着色，便于之后计算（提前计算）</li>
</ol>
<h2 id="heading-60"><a class="anchor" href="#heading-60">#</a> 几何</h2>
<h3 id="heading-61"><a class="anchor" href="#heading-61">#</a> 隐式表示法</h3>
<h4 id="heading-62"><a class="anchor" href="#heading-62">#</a> 代数表示</h4>
<p>使用数学公式定义一个形状，缺点在于复杂形状描述困难。有CSG（Constructive Solid Geometry），通过简单几何的运算（交并）得到复杂几何，建模软件广泛应用。</p>
<h4 id="heading-63"><a class="anchor" href="#heading-63">#</a> 距离函数</h4>
<p>距离函数指空间上一个点到物体表面或边界的最小距离。对两个物体的距离函数进行运算，之后再转化为实体（取 f (x)=0 的点）。</p>
<h4 id="heading-64"><a class="anchor" href="#heading-64">#</a> 分形</h4>
<p>递归方法</p>
<h3 id="heading-65"><a class="anchor" href="#heading-65">#</a> 显式表示法</h3>
<p>直接给出目标坐标和源坐标的映射关系，通过函数或参数映射的方式表述。</p>
<h4 id="heading-66"><a class="anchor" href="#heading-66">#</a> 点云</h4>
<p>点云使用无数离散的点描述一个形体，它是一个 (x, y, z) 的列表，理论上能表述任何物体</p>
<h4 id="heading-67"><a class="anchor" href="#heading-67">#</a> 多边形面</h4>
<p>常用三角形/四边形，可以表述很多几何体，应用最为广泛</p>
<blockquote>
<p>. obj 文件使用文本表示点的坐标、法线、纹理</p>
</blockquote>
<h3 id="heading-68"><a class="anchor" href="#heading-68">#</a> 曲线</h3>
<h4 id="heading-69"><a class="anchor" href="#heading-69">#</a> 贝塞尔曲线</h4>
<p>使用一系列的控制点定义一条曲线</p>
<p><img src="https://picdl.sunbangyan.cn/2023/06/18/ix90zy.png" alt=""></p>
<p>贝塞尔曲线符合伯恩斯坦多项式：</p>
<p><img src="https://www.zhihu.com/equation?tex=%5Cbbox%5Bwhite%5D%7B%0Ab%5En%28t%29%3D%5Csum%5Climits%5En%5Climits_%7Bj%3D0%7Db_%7Bj%7DB_%7Bj%7D%5En%28t%29%0A%7D" alt="">
对 n=3，<img src="https://www.zhihu.com/equation?tex=%5Cbbox%5Bwhite%5D%7B+b_%7B0%7D%3D%280%2C2%2C3%29+%5Cquad+b_%7B1%7D%3D%282%2C3%2C5%29%5Cquad+b_%7B2%7D%3D%286%2C7%2C9%29%5Cquad+b_%7B3%7D%3D%283%2C4%2C5%29%7D" alt=""></p>
<p>有:</p>
<p><img src="https://www.zhihu.com/equation?tex=%5Cbbox%5Bwhite%5D%7Bb%5En%28t%29%3Db_%7B0%7D%281-t%29%5E3%2Bb_%7B1%7D3t%281-t%29%5E2%2Bb_%7B2%7D3t%5E2%281-t%29%2Bb_%7B3%7Dt%5E3%7D" alt=""></p>
<p>性质：</p>
<ol>
<li>过起点和终点:<img src="https://www.zhihu.com/equation?tex=%5Cbbox%5Bwhite%5D%7Bb%280%29%3Db_%7B0%7D%5Cquad+b%281%29%3Db_%7B3%7D%7D" alt=""></li>
<li><img src="https://www.zhihu.com/equation?tex=%5Cbbox%5Bwhite%5D%7Bb%27%280%29%3D3%28b_%7B1%7D-b_%7B0%7D%29+%5Cquad+b%27%281%29%3D3%28b_%7B3%7D-b_%7B2%7D%29%7D" alt=""></li>
<li>仿射变换最终结果只与控制点有关</li>
<li>凸包性：线上的任何一个点必在控制点围成的凸包之内</li>
</ol>
<h4 id="-piecewise-"><a class="anchor" href="#-piecewise-">#</a> 逐段 (Piecewise) 贝塞尔曲线</h4>
<p>为解决贝塞尔曲线难以控制的问题，每四个点定义一个（三次）贝塞尔曲线。</p>
<p>为保证两段曲线连续且光滑，要求两个端控制点重合，旁边的两个控制点共线。</p>
<p>C0 连续：两条曲线连续，即端点重合
C1 连续：切线连续，要求两个点（第一条曲线的 2 点和另一条曲线的 1 点）共线且距离相同</p>
<h4 id="b-"><a class="anchor" href="#b-">#</a> B 样条</h4>
<p>对贝塞尔曲线的改进，避免改变一个点就会影响全部的缺点（具有局部性）</p>
<h3 id="heading-70"><a class="anchor" href="#heading-70">#</a> 曲面/网格</h3>
<p>曲面即曲线的延伸。在两个方向上分别定义贝塞尔曲线，从而得到贝塞尔曲面。</p>
<h4 id="heading-71"><a class="anchor" href="#heading-71">#</a> 网格优化</h4>
<ol>
<li>网格细分：增加三角形</li>
<li>网格简化</li>
<li>网格正则化</li>
</ol>
<h4 id="heading-72"><a class="anchor" href="#heading-72">#</a> 网格细分</h4>
<h5 id="loop-"><a class="anchor" href="#loop-">#</a> loop 细分</h5>
<ol>
<li>细分：从三角形三边中点将三角形分为四部分</li>
<li>调整三角形各顶点的位置：新顶点的值是其周围四个点的平均（加权 1/8 和 3/8）；老顶点的值是其周围顶点和它自己的值的加权</li>
</ol>
<h5 id="catmull-clark-"><a class="anchor" href="#catmull-clark-">#</a> Catmull-Clark 细分</h5>
<p>概念：</p>
<ol>
<li>四边形面和非四边形面</li>
<li>奇异点：度不为 4 的点</li>
</ol>
<p>非四边形面在一次 Catmull-Clark 细分后转化为奇异点，非四边形面消失。</p>
<p><img src="https://picdl.sunbangyan.cn/2023/06/18/uc1da7.png" alt=""></p>
<h4 id="heading-73"><a class="anchor" href="#heading-73">#</a> 网格简化</h4>
<p>目标是减少网格数量同时维持大体的形状</p>
<p>其中一种方法是边坍缩，边选择的手段是二次误差度量。二次误差度量即计算点到各边的距离的平方之和，使它的值最小。因为一条边的坍缩可能影响其他边，需要使用优先队列确定坍缩的顺序。</p>
<h2 id="heading-74"><a class="anchor" href="#heading-74">#</a> 光线追踪</h2>
<h3 id="shadow-mapping"><a class="anchor" href="#shadow-mapping">#</a> Shadow Mapping</h3>
<h4 id="heading-75"><a class="anchor" href="#heading-75">#</a> 步骤</h4>
<ol>
<li>从光源看向场景，记录深度</li>
<li>从相机看向场景，投影回光源，比较记录的深度是否一致，若不同，则在阴影中。</li>
</ol>
<h4 id="heading-76"><a class="anchor" href="#heading-76">#</a> 缺点</h4>
<ol>
<li>浮点数由于存在数值精度问题，在判定相等时存在困难</li>
<li>分辨率过小出现锯齿，分辨率过大则开销大</li>
</ol>
</article>
  </div>
</body>

</html>