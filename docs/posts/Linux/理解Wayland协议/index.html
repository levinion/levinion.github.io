<!doctype html>
<html data-theme="dark">
  <head>
    
<meta charset="UTF-8" />
<meta http-equiv="X-UA-Compatible" content="IE=edge" />
<meta name="viewport" content="width=device-width, initial-scale=1.0" />
<link rel="stylesheet" href="/assets/css/pico.css" />
<link rel="stylesheet" href="/assets/css/custom.css" />
<link
  rel="stylesheet"
  href="//cdnjs.cloudflare.com/ajax/libs/highlight.js/11.7.0/styles/atom-one-dark.min.css"
/>
<script src="//cdnjs.cloudflare.com/ajax/libs/highlight.js/11.7.0/highlight.min.js"></script>
<script>
  hljs.initHighlightingOnLoad();
</script>


    <style>
      article {
        background: rgb(28, 29, 33);
        max-width: 70%;
        text-align: left;
        margin: 0 auto;
        border-radius: 30px;
      }

      @media (max-width: 768px) {
        article {
          max-width: 90%;
        }

        h1 {
          font-size: large;
        }

        .date {
          font-size: medium;
        }

        p,
        li {
          font-size: 15px;
        }
      }

      p,
      li {
        font-size: 16.5px;
        line-height: 32px;
      }

      h1 {
        text-align: center;
        margin-bottom: 10px;
      }

      .meta p {
        text-align: center;
      }

      .date {
        text-align: center;
      }

      .toc {
        position: fixed;
        float: left;
        max-width: 50px;
        max-height: 50px;
        margin-top: 200px;
        text-align: center;
      }

      h2 {
        font-size: x-large;
        color: peru;
      }

      h3 {
        font-size: large;
        color: rgb(205, 158, 112);
      }

      h4 {
        font-size: medium;
        color: pink;
      }

      strong {
        color: rgb(182, 230, 240);
      }

      del {
        color: rgb(115, 130, 140);
      }
    </style>
    <title>理解Wayland协议</title>
  </head>

  
  
  <body>
    
<nav>
  <a href="/" class="logo">Maruka's Blog</a>
  <div class="breadcrumb">
    <ul>
      <li>
        <a href="/posts">文章</a>
      </li>
      <li>
        <a href="/category">分类</a>
      </li>
      <li>
        <a href="/about">关于</a>
      </li>
    </ul>
  </div>
</nav>

    <div>
      <div class="meta">
        <h1>理解Wayland协议</h1>
        <p>2025-09-11 00:01:32</p>
      </div>
      <article><h2 id="heading"><a class="anchor" href="#heading">#</a> 协议</h2>
<p>Wayland 本身是个协议。协议，也就是对等实体（我们对 Peer 的翻译）之间沟通的方式。</p>
<p>假设说有小明和小王两个人，他们隔着一堵墙，他们只能靠敲墙来进行沟通。他们已经事先交换了暗号：敲一下表示自己想要吃苹果，敲两下表示自己想要吃梨。这样，当小明听到小王敲了两下墙时，他就知道小王想要吃梨而不是苹果。</p>
<p>协议就相当于这个故事中的暗号，遵守且正确实现同一协议的双方能够没有歧义地交换和处理数据。</p>
<h2 id="libwayland"><a class="anchor" href="#libwayland">#</a> libwayland</h2>
<p>libwayland 是一个库，它是对 Wayland 协议的一个实现。它分为两个部分，client 和 server。在 server 端，也就是合成器端，libwayland 定义了一系列全局对象，接收从客户端发来的「请求」，从而对窗口进行调度。在客户端，则是绑定到合成器创建的对象，渲染帧，并将帧交给合成器。</p>
<p>客户端和服务端的沟通是通过套接字（socket）实现的。套接字的路径在大多数情况下由 <code>WAYLAND_DISPLAY</code> 环境变量指定。如果未设置该环境变量，部分应用程序会去找 <code>$XDG_RUNTIME_DIR/wayland-X</code>。</p>
<p>在合成器启动时，一般会主动设置当前的 <code>WAYLAND_DISPLAY</code> 环境变量。它的值一般是 <code>wayland-0</code>，如果启动了多个合成器，这个值会往上累计，变成 <code>wayland-1</code>、<code>wayland-2</code> 等等。</p>
<p>libwayland 在客户端的工作大概是：</p>
<ul>
<li>根据环境变量获取套接字路径</li>
<li>打开套接字</li>
<li>发送请求</li>
<li>循环接收和处理合成器发来的事件</li>
</ul>
<p>从上面可以看出，它所做的核心工作无非就是发送和接收信息，因此一个 wayland 客户端完全可以不使用 libwayland 而自行处理与套接字的交互逻辑。这样做的好处是能摆脱 libwayland 那糟糕的 XML 文件以及非常不灵活的回调函数。</p>
<h2 id="heading-1"><a class="anchor" href="#heading-1">#</a> 格式</h2>
<p>一个客户端请求分为请求头和请求体。请求头共 8 个字节，包括：</p>
<ul>
<li>方法所在的对象的 id：4 个字节</li>
<li>所要调用的方法 opcode：2 个字节</li>
<li>消息（请求头 + 请求体）的长度：2 个字节</li>
</ul>
<p>请求体长度没有要求，它所占的字节数可以由长度字段的值减去 8 个字节得到。</p>
<p>对于长度可变类型如字符串，则采用字符串长度 + 字符串的方式进行发送。另外，它需要按照 4 字节对齐，不足的地方补 0。</p>
<p>下面让我们来分析一个定义了协议的 XML 文件。它可以在 <code>cat /usr/share/wayland-protocols/stable/xdg-shell/xdg-shell.xml</code> 中找到。借助 <code>wayland-scanner</code> 可以从这个 XML 文件生成 C 胶水代码，此处就不讲了。</p>
<pre><code class="language-xml">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;
&lt;protocol name=&quot;xdg_shell&quot;&gt;
  &lt;interface name=&quot;xdg_wm_base&quot; version=&quot;7&quot;&gt;
    ...
  &lt;/interface&gt;
  &lt;interface name=&quot;xdg_positioner&quot; version=&quot;7&quot;&gt;
    ...
  &lt;/interface&gt;
  &lt;interface name=&quot;xdg_toplevel&quot; version=&quot;7&quot;&gt;
    ...
  &lt;/interface&gt;
&lt;/protocol&gt;
</code></pre>
<p>XML 的最外层定义了该协议的名称为 <code>xdg_shell</code>。这是用来创建各种角色窗口（Toplevel、Popup）的一个基础协议。一个协议中会包含一到多个 interface。interface 也就是接口，或命名空间，它里面定义了多个方法。</p>
<pre><code class="language-xml">
&lt;interface name=&quot;xdg_toplevel&quot; version=&quot;7&quot;&gt;
  ...
  &lt;request name=&quot;set_title&quot;&gt;
    &lt;arg name=&quot;title&quot; type=&quot;string&quot;/&gt;
  &lt;/request&gt;
  ...
&lt;/interface&gt;
</code></pre>
<p>如 <code>xdg_toplevel</code> 接口中的 <code>set_title</code> 方法，它需要接收一个 string 类型的参数。</p>
<p>假设我们有一个向套接字发送消息的工具函数：</p>
<pre><code class="language-cpp">template&lt;typename... Args&gt;
void send_msg(const uint32_t id, const uint16_t opcode, Args... args);
</code></pre>
<p>我们已经提前获取到了 <code>toplevel</code> 对象，它的 id 是一个 u32 类型数据，让我们叫它 <code>toplevel_id</code>。</p>
<p>于是，我们可以这样发送请求：</p>
<pre><code class="language-cpp">send_msg(toplevel_id, 2, &quot;hello-world&quot;)
</code></pre>
<p>这里 opcode 为 2，因为我们调用的是 <code>xdg_toplevel</code> 这个 interface 下的第三个方法。</p>
<p>对于合成器事件，和上面所说的大体相同，不同之处在于字段名为 event 而不是 request。另外，一个 interface 下的 request 和 event 的 opcode 独立。</p>
</article>
    </div>
  </body>
</html>
